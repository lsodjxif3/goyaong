<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Zombie Shooter â€” ë¬´í•œ ì¢€ë¹„ ìŠˆí„°</title>
  <style>
    :root{font-family:Inter,system-ui,Segoe UI,Roboto,'Noto Sans KR',sans-serif}
    html,body{height:100%;margin:0;background:#0f1724;color:#e6eef8}
    #ui{position:fixed;left:12px;top:12px;z-index:10;background:rgba(0,0,0,0.8);padding:12px;border-radius:10px;border:2px solid rgba(255,255,255,0.1);min-width:200px;transform-origin:top left;transform:scale(0.92)}
    #ui .big{font-size:18px;font-weight:700;margin-bottom:6px;color:#4ade80;text-shadow:0 0 10px rgba(74,222,128,0.5)}
    #ui .small{font-size:13px;opacity:.9;margin-bottom:8px}
    .health-bar{width:100%;height:16px;background:rgba(0,0,0,0.5);border-radius:10px;overflow:hidden;border:2px solid rgba(255,255,255,0.2);margin-bottom:6px}
    .health-fill{height:100%;background:linear-gradient(90deg,#ef4444,#f97316);transition:width 0.3s ease;border-radius:8px}
    .health-text{font-size:12px;text-align:center;margin-top:4px;color:#fff;font-weight:600}
    canvas{display:block;margin:0 auto;background:linear-gradient(#111827,#071029);box-shadow:0 6px 30px rgba(2,6,23,.7);border-radius:8px}
    #controls{position:fixed;right:12px;top:12px;text-align:right}
    button{background:#111827;color:#e6eef8;border:1px solid rgba(255,255,255,.06);padding:8px 12px;border-radius:6px;cursor:pointer}
    button:hover{transform:translateY(-1px)}
    .center-msg{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center}
    .center-msg h1{margin:0 0 8px 0;font-size:28px}
    .center-msg p{margin:0 0 12px 0;color:#cbd5e1}
    #weapon-name{font-weight:700;margin-left:10px}
    #grenade-status{font-size:13px;margin-top:6px;opacity:.9}
    #buffs{position:fixed;left:12px;bottom:12px;z-index:10;max-width:300px;max-height:40vh;overflow:auto}
    .buff-item{background:rgba(0,0,0,0.7);padding:3px 6px;margin:2px 0;border-radius:4px;font-size:11px;border-left:3px solid #4ade80;line-height:1.25}
    .card-overlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);padding:20px;border-radius:12px;z-index:100;display:none;text-align:center;min-width:540px;border:2px solid rgba(74,222,128,0.3)}
    .card{background:linear-gradient(135deg,#1e293b,#334155);padding:15px;margin:10px;border-radius:8px;cursor:pointer;border:2px solid transparent;transition:all 0.2s;display:inline-block;width:170px;vertical-align:top}
    .card:hover{border-color:#4ade80;transform:scale(1.05);box-shadow:0 0 20px rgba(74,222,128,0.3)}
    .card-title{font-weight:700;color:#4ade80;margin-bottom:8px;font-size:14px}
    .card-desc{font-size:11px;color:#cbd5e1;line-height:1.3}
    
    /* ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ */
    .mobile-controls{position:fixed;bottom:20px;left:20px;display:none;z-index:20}
    .joystick{width:80px;height:80px;border:3px solid rgba(255,255,255,0.3);border-radius:50%;background:rgba(0,0,0,0.5);position:relative}
    .joystick-knob{width:30px;height:30px;background:#4ade80;border-radius:50%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transition:all 0.1s}
    
    /* ì´ë™ì‹ ê³µê²© ì¡°ì´ìŠ¤í‹± */
    .attack-joystick{width:100px;height:100px;border:3px solid rgba(239,68,68,0.5);border-radius:50%;background:rgba(239,68,68,0.2);position:fixed;display:none;z-index:20;cursor:pointer}
    .attack-joystick-knob{width:35px;height:35px;background:#ef4444;border-radius:50%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transition:all 0.1s;box-shadow:0 0 10px rgba(239,68,68,0.5)}
    
    /* ëª¨ë°”ì¼ ë²„íŠ¼ë“¤ */
    .mobile-button{width:60px;height:60px;border:3px solid rgba(255,255,255,0.3);border-radius:50%;background:rgba(0,0,0,0.7);display:none;z-index:20;cursor:pointer;position:fixed;display:flex;align-items:center;justify-content:center;font-size:20px;font-weight:bold;color:#fff;user-select:none;-webkit-user-select:none}
    .mobile-button:active{transform:scale(0.95);background:rgba(255,255,255,0.2)}
    
    .grenade-btn{background:rgba(245,158,11,0.8)}
    .weapon-btn{background:rgba(139,92,246,0.8)}
    
    /* ëª¨ë°”ì¼ UI í•˜ë‹¨ ë°°ì¹˜ */
    .mobile-ui{position:fixed;bottom:10px;left:10px;right:10px;display:none;z-index:15;background:rgba(0,0,0,0.8);border-radius:10px;padding:8px;border:1px solid rgba(255,255,255,0.1)}
    .mobile-ui-content{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:#e6eef8}
    .mobile-score{font-weight:700;color:#4ade80}
    .mobile-health{display:flex;align-items:center;gap:8px}
    .mobile-health-bar{width:60px;height:8px;background:rgba(0,0,0,0.5);border-radius:4px;overflow:hidden}
    .mobile-health-fill{height:100%;background:linear-gradient(90deg,#ef4444,#f97316);transition:width 0.3s ease;border-radius:4px}
    
    /* ì„¸ë¡œ ëª¨ë“œ ê¶Œì¥ ë©”ì‹œì§€ */
    .orientation-notice{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);color:#fff;padding:20px;border-radius:10px;text-align:center;z-index:100;display:none;border:2px solid #4ade80}
    
    @media (max-width: 768px) {
      .mobile-controls{display:block}
      .attack-joystick{display:block}
      .mobile-button{display:flex}
      .mobile-ui{display:block}
      #controls-left{display:none}
      #ui{display:none}
      #controls{display:none}
      #buffs{display:none}
      canvas{max-width:100vw;max-height:100vh;width:auto;height:auto}
    }
    
    @media (orientation: landscape) and (max-width: 768px) {
      .orientation-notice{display:block}
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="big">Score: <span id="score">0</span></div>
    <div class="health-bar">
      <div class="health-fill" id="healthFill"></div>
    </div>
    <div class="health-text" id="healthText">100 / 100</div>
    <div class="small">Zombies: <span id="zcount">0</span></div>
  </div>
  <div id="controls-left" style="position:fixed;left:12px;top:200px;z-index:10;background:rgba(0,0,0,0.8);padding:12px;border-radius:10px;border:2px solid rgba(255,255,255,0.1);min-width:200px;transform-origin:top left;transform:scale(0.85);font-size:12px;color:#e6eef8;line-height:1.4;">
    <div style="font-weight:700;margin-bottom:8px;color:#4ade80;">ì¡°ì‘ë²•</div>
    <div>WASD / ë°©í–¥í‚¤ : ì´ë™</div>
    <div>ë§ˆìš°ìŠ¤ : ì¡°ì¤€</div>
    <div>í´ë¦­/Space : ë°œì‚¬</div>
    <div>Q/E/X : ë¬´ê¸°ì „í™˜</div>
    <div>R : ìˆ˜ë¥˜íƒ„(ê¶ê·¹ê¸°)</div>
    <div>P : ì¼ì‹œì •ì§€</div>
    <div style="color:#cbd5e1;font-size:10px;margin-top:8px;">ëª¨ë°”ì¼: í„°ì¹˜ë¡œ ì¡°ì‘</div>
    
    <div style="font-weight:700;margin-top:16px;margin-bottom:8px;color:#fbbf24;">ìµœê³  ì ìˆ˜</div>
    <div id="high-scores" style="font-size:11px;line-height:1.2;"></div>
  </div>
  <div id="controls">
    <div style="margin-bottom:8px">ë¬´ê¸°: <span id="weapon-name">ê¸°ë³¸ ì´</span></div>
    <div id="grenade-status">ìˆ˜ë¥˜íƒ„: ì¤€ë¹„ ì¤‘...</div>
    <div style="margin-top:8px"><button id="pauseBtn">ì¼ì‹œì •ì§€</button>
    <button id="restartBtn">ì¬ì‹œì‘</button></div>
  </div>

  <canvas id="game" width="960" height="640"></canvas>
  
  <!-- ëª¨ë°”ì¼ í„°ì¹˜ ì»¨íŠ¸ë¡¤ -->
  <div class="mobile-controls">
    <div class="joystick" id="joystick">
      <div class="joystick-knob" id="joystickKnob"></div>
    </div>
  </div>
  
  <!-- ì´ë™ì‹ ê³µê²© ì¡°ì´ìŠ¤í‹± -->
  <div class="attack-joystick" id="attackJoystick">
    <div class="attack-joystick-knob" id="attackJoystickKnob"></div>
  </div>
  
  <!-- ëª¨ë°”ì¼ ë²„íŠ¼ë“¤ -->
  <div class="mobile-button grenade-btn" id="mobileGrenadeBtn">ğŸ’£</div>
  <div class="mobile-button weapon-btn" id="mobileWeaponBtn">âš”ï¸</div>
  
  <!-- ëª¨ë°”ì¼ UI -->
  <div class="mobile-ui">
    <div class="mobile-ui-content">
      <div class="mobile-score">Score: <span id="mobileScore">0</span></div>
      <div class="mobile-health">
        <span>HP:</span>
        <div class="mobile-health-bar">
          <div class="mobile-health-fill" id="mobileHealthFill"></div>
        </div>
        <span id="mobileHealthText">100/100</span>
      </div>
    </div>
  </div>
  
  <!-- ì„¸ë¡œ ëª¨ë“œ ê¶Œì¥ ë©”ì‹œì§€ -->
  <div class="orientation-notice">
    <h3>ğŸ“± ì„¸ë¡œ ëª¨ë“œ ê¶Œì¥</h3>
    <p>ë” ë‚˜ì€ ê²Œì„ ê²½í—˜ì„ ìœ„í•´<br>ì„¸ë¡œ ëª¨ë“œë¡œ íšŒì „í•´ì£¼ì„¸ìš”!</p>
  </div>

  <div class="center-msg" id="overlay" style="display:none">
    <h1 id="overlay-title">Game Over</h1>
    <p id="overlay-sub">í´ë¦­í•˜ê±°ë‚˜ ì¬ì‹œì‘ ë²„íŠ¼ìœ¼ë¡œ ì¬ì‹œì‘</p>
    <div style="margin-top:12px"><button id="overlayBtn">ê³„ì†</button></div>
  </div>

  <div class="center-msg" id="startOverlay" style="display:block;background:rgba(0,0,0,0.95);padding:30px;border-radius:15px;border:2px solid #4ade80;">
    <h1 style="color:#4ade80;margin-bottom:16px;">ğŸ§Ÿâ€â™‚ï¸ Zombie Shooter</h1>
    <div style="text-align:left;max-width:400px;margin:0 auto;line-height:1.6;">
      <div style="margin-bottom:12px;"><strong>ğŸ® ì¡°ì‘ë²•:</strong></div>
      <div>â€¢ WASD / ë°©í–¥í‚¤: ì´ë™</div>
      <div>â€¢ ë§ˆìš°ìŠ¤: ì¡°ì¤€</div>
      <div>â€¢ í´ë¦­/Space: ë°œì‚¬</div>
      <div>â€¢ Q/E/X: ë¬´ê¸° ì „í™˜</div>
      <div>â€¢ R: ìˆ˜ë¥˜íƒ„</div>
      <div>â€¢ P: ì¼ì‹œì •ì§€</div>
      <div style="margin-top:12px;color:#cbd5e1;">ğŸ“± ëª¨ë°”ì¼: í„°ì¹˜ë¡œ ì¡°ì‘</div>
    </div>
    <div style="margin-top:20px;color:#cbd5e1;font-size:14px;">
      ì¢€ë¹„ë¥¼ ì²˜ì¹˜í•˜ê³  ì¹´ë“œë¥¼ ìˆ˜ì§‘í•˜ì—¬ ê°•í•´ì§€ì„¸ìš”!
    </div>
    <div style="margin-top:16px"><button id="startBtn" style="background:#4ade80;color:#000;border:none;padding:12px 24px;border-radius:8px;font-weight:700;cursor:pointer;">ê²Œì„ ì‹œì‘</button></div>
  </div>

  <div id="buffs">
    <div style="font-weight:700;margin-bottom:8px;color:#4ade80">í™œì„± ë²„í”„:</div>
    <div id="buff-list"></div>
  </div>

  <div class="card-overlay" id="cardOverlay">
    <h2 style="color:#4ade80;margin-bottom:8px" id="cardTitle">ì¹´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”!</h2>
    <div id="cardContainer"></div>
    <div id="pickHint" style="color:#cbd5e1;font-size:12px;margin-top:6px"></div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const healthEl = document.getElementById('healthText');
  const healthFill = document.getElementById('healthFill');
  const zcountEl = document.getElementById('zcount');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const overlay = document.getElementById('overlay');
  const overlayBtn = document.getElementById('overlayBtn');
  const startOverlay = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');
  const joystick = document.getElementById('joystick');
  const joystickKnob = document.getElementById('joystickKnob');
  const attackJoystick = document.getElementById('attackJoystick');
  const attackJoystickKnob = document.getElementById('attackJoystickKnob');
  const mobileGrenadeBtn = document.getElementById('mobileGrenadeBtn');
  const mobileWeaponBtn = document.getElementById('mobileWeaponBtn');
  const mobileScore = document.getElementById('mobileScore');
  const mobileHealthFill = document.getElementById('mobileHealthFill');
  const mobileHealthText = document.getElementById('mobileHealthText');
  const weaponNameEl = document.getElementById('weapon-name');
  const grenadeStatusEl = document.getElementById('grenade-status');
  const cardOverlay = document.getElementById('cardOverlay');
  const cardContainer = document.getElementById('cardContainer');
  const cardTitle = document.getElementById('cardTitle');
  const pickHint = document.getElementById('pickHint');
  const buffList = document.getElementById('buff-list');

  const W = canvas.width, H = canvas.height;
  let lastTime = 0, running = true, score = 0;
  const keys = {};
  const mouse = {x: W/2, y: H/2, down:false};
  const rand = (min,max)=> Math.random()*(max-min)+min;
  
  // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ë³€ìˆ˜
  let joystickActive = false;
  let joystickCenter = {x: 0, y: 0};
  let joystickOffset = {x: 0, y: 0};
  
  let attackJoystickActive = false;
  let attackJoystickCenter = {x: 0, y: 0};
  let attackJoystickOffset = {x: 0, y: 0};
  let attackJoystickPosition = {x: 0, y: 0};

  const BASE_WEAPONS = [
    { id: 'basic', name: 'ê¸°ë³¸ ì´', damage: 20, fireRate: 60, bulletSpeed: 560, bulletR:8, color:'#fff' },
    { id: 'power', name: 'ê°•ë ¥ ì´', damage: 1000, fireRate: 900, bulletSpeed: 850, bulletR:14, color:'#ffde33' },
    { id: 'pierce', name: 'ê´€í†µ ëŒ€í¬', damage: 900, fireRate: 800, bulletSpeed: 400, bulletR:16, color:'#ff4444', pierce: true }
  ];
  const weapons = JSON.parse(JSON.stringify(BASE_WEAPONS));
  let currentWeapon = 0;
  const player = { x: W/2, y: H-80, r: 14, speed: 220, health: 100, lastShot: 0, maxHealth: 100 };

  let bullets = [];
  let zombies = [];
  let bosses = [];
  let cards = [];
  let flameOrbs = [];
  let poisonPools = [];
  let healingOrbs = [];
  let floatingTexts = [];
  let bloodPools = [];

  // Grenades handling (support queuing from buffs)
  let grenades = [];
  let grenadeCooldown = 5000;
  let lastGrenade = -99999;
  let queuedGrenades = [];

  let spawnTimer = 0, spawnInterval = 1200, difficultyTimer = 0, bossTimer = 0, mutantTimer = 0;
  let flashTime = 0, flashX = 0, flashY = 0, flashR = 0; let cameraShake = 0;
  let autoShootTimer = 0, poisonTimer = 0, flameOrbAngle = 0;
  let powerBurstTimer = 0; // ë²„í”„12
  let swordTimer = 0; // ë²„í”„10
  let safeguardWindow = []; // ë²„í”„9 í”¼ê²© íƒ€ì„ìŠ¤íƒ¬í”„
  let safeguardActive = false; let safeguardUntil = 0;

  // íŠ¹ë³„ ë²„í”„ ê´€ë ¨ ë³€ìˆ˜
  let catPetTimer = 0; // ê³ ì–‘ì´ í« íƒ€ì´ë¨¸
  let basicShotCount = 0; // ê¸°ë³¸ì´ ë°œì‚¬ ì¹´ìš´íŠ¸
  let chainExplosions = []; // ì—°ì‡„ í­ë°œ
  let slowedEnemies = []; // ìŠ¬ë¡œìš°ëœ ì ë“¤
  let cursedEnemies = []; // ì €ì£¼ë°›ì€ ì ë“¤
  
  // ì‹ ê·œ ë²„í”„ ë³€ìˆ˜
  let valkyrieBlessingActive = false; // ë°œí‚¤ë¦¬ì˜ ì¶•ë³µ í™œì„±í™” ìƒíƒœ
  let powerShotCount = 0; // ê°•ë ¥ì´ ì—°ì† ë°œì‚¬ ì¹´ìš´íŠ¸
  let dogPetTimer = 0; // ê°•ì•„ì§€ í« íƒ€ì´ë¨¸
  let flameExplosions = []; // í™”ì—¼ í­ë°œ
  let flamePools = []; // í™”ì—¼ ì¥íŒ
  
  // í”Œë ˆì´ì–´ ê°ì„± ë³€ìˆ˜
  let playerDistance = 0; // í”Œë ˆì´ì–´ ì´ë™ ê±°ë¦¬ ì¶”ì 
  let lastPlayerX = 0, lastPlayerY = 0; // ì´ì „ ìœ„ì¹˜
  
  // ë§ˆìŠ¤í„° ë²„í”„ ë³€ìˆ˜
  let enhancedBulletHits = new Map(); // ê°•í™” íƒ„í™˜ íˆíŠ¸ ì¹´ìš´íŠ¸ (ì ë³„)
  let powerWeaponSwitchTimer = 0; // ê°•ë ¥ì´ ë¬´ê¸° ì „í™˜ íƒ€ì´ë¨¸
  let powerWeaponSwitchCooldown = 0; // ê°•ë ¥ì´ ë¬´ê¸° ì „í™˜ ì¿¨íƒ€ì„
  
  // ê²Œì„ ì‹œê°„ ê´€ë ¨ ë³€ìˆ˜
  let gameStartTime = 0;
  let isLateGame = false; // 25ë¶„ í›„ ì²´í¬

  // í†µê³„ ì‹œìŠ¤í…œ
  let highScores = JSON.parse(localStorage.getItem('zombieShooter_highScores') || '[]');
  let weaponDamage = { basic: 0, power: 0, pierce: 0 };
  const highScoresEl = document.getElementById('high-scores');

  // ì¹´ë“œ ì„ íƒ ë‚¨ì€ íšŸìˆ˜ (ëŒì—°ë³€ì´ ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ 2)
  let cardPicksRemaining = 0;
  let specialRewardMode = false; // ëª¨ë“  ë²„í”„ íšë“ ì‹œ ìŠ¤í˜ì…œ ì¹´ë“œë§Œ ì œê³µ ëª¨ë“œ

  // ë²„í”„ ì‹œìŠ¤í…œ (ê¸°ì¡´ 13 + ì‹ ê·œ 17 + íŠ¹ë³„ 10 + í”„ë¦¬ì¦˜ 3 = 43ê°œ)
  const buffs = {
    grenadeCooldown: false,
    pierceSize: false,
    zombieExplode: false,
    speedDodge: false,
    doubleHealth: false,
    autoPierce: false,
    healingOrbs: false,
    flameOrbs: false,
    poisonPools: false,
    pierceCount: false,
    burnEffect: false,
    bossDamage: false,
    grenadeRange: false,

    // ì‹ ê·œ 1~17
    g_doubleCast10: false,        // 1
    pierceFaster200: false,       // 2
    powerFaster150: false,        // 3
    powerBurn80: false,           // 4
    powerExtraBullet20: false,    // 5
    basicMega005: false,          // 6 (ê·¹ëŒ€ íƒ„)
    buffGrenadePlus100: false,    // 7
    grenadePlus200And10pctHP: false, // 8
    safeguard5s: false,           // 9
    swordEvery10s: false,         // 10
    score15On1pct: false,         // 11
    powerRadial10s: false,        // 12
    grenadePlus50OnDOT: false,    // 13
    powerKnockback: false,        // 14
    basicInstakillRare: false,    // 15 (ì‹ ì˜ íƒ„í™˜)
    basicPlus35: false,           // 16 (+320ìœ¼ë¡œ ìƒí–¥)
    pierceCrit20: false,          // 17

    // íŠ¹ë³„ ë…¸ë‘ ë²„í”„ 1~10
    gravityField: false,          // 1: ì¤‘ë ¥ì¥
    scoreDamageBoost: false,      // 2: ìŠ¤ì½”ì–´ ë°ë¯¸ì§€ ë¶€ìŠ¤íŠ¸
    lifeSteal: false,             // 3: ìƒëª…ë ¥ í¡ìˆ˜
    pierceSlow: false,            // 4: ê´€í†µ ìŠ¬ë¡œìš°
    powerGrenadeDrop: false,      // 5: ê°•ë ¥ì´ ìˆ˜ë¥˜íƒ„ ë“œë¡­
    catPet: false,                // 6: ê³ ì–‘ì´ í«
    valkyrieCurse: false,         // 7: ë°œí‚¤ë¦¬ì˜ ì €ì£¼
    basicBurst: false,            // 8: ê¸°ë³¸ì´ ë²„ìŠ¤íŠ¸
    powerSpeedCrit: false,        // 9: ê°•ë ¥ì´ ì†ë„+ì¹˜ëª…íƒ€
    grenadeChain: false,          // 10: ìˆ˜ë¥˜íƒ„ ì—°ì‡„í­ë°œ
    
    // ì‹ ê·œ ë…¸ë‘ ë²„í”„ 11~17
    valkyrieBlessing: false,      // 11: ë°œí‚¤ë¦¬ì˜ ì¶•ë³µ
    powerSmallBullet: false,      // 12: ê°•ë ¥ì´ ì‘ì€ ì¶”ê°€ íƒ„í™˜
    superCritical: false,         // 13: ê°•ë ¥ ì¹˜ëª…íƒ€
    pierceEnhanced: false,        // 14: ê´€í†µëŒ€í¬ ê°•í™” íƒ„í™˜
    dogPet: false,                // 15: ê°•ì•„ì§€ í«
    dotBoost: false,              // 16: DOT ì¶”ê°€ ë°ë¯¸ì§€
    basicCritical: false,         // 17: ê¸°ë³¸ì´ ì¹˜ëª…íƒ€

    // í”„ë¦¬ì¦˜ ë²„í”„ 1~5
    basicAwakening: false,        // 1: ê¸°ë³¸ì´ ê°ì„±
    powerAwakening: false,        // 2: ê°•ë ¥ì´ ê°ì„±
    pierceAwakening: false,       // 3: ê´€í†µëŒ€í¬ ê°ì„±
    grenadeAwakening: false,      // 4: ìˆ˜ë¥˜íƒ„ ê°ì„±
    playerAwakening: false,       // 5: í”Œë ˆì´ì–´ ê°ì„±
    
    // ë§ˆìŠ¤í„° ë²„í”„ 1~3
    basicEnhancedBullets: false,  // 1: ê¸°ë³¸ì´ ê°•í™” íƒ„í™˜
    powerRapidFire: false,        // 2: ê°•ë ¥ì´ ì—°ì‚¬
    piercePenetration: false      // 3: ê´€í†µëŒ€í¬ ê´€í†µë ¥
  };

  const buffNames = {
    grenadeCooldown: "ìˆ˜ë¥˜íƒ„ ì¿¨íƒ€ì„ 1ì´ˆ",
    pierceSize: "ê´€í†µëŒ€í¬ í¬ê¸° ì¦ê°€",
    zombieExplode: "ì¢€ë¹„ í­ë°œ íš¨ê³¼",
    speedDodge: "ê³ ì† íšŒí”¼ + ìˆ˜ë¥˜íƒ„",
    doubleHealth: "ì²´ë ¥ 2ë°°",
    autoPierce: "ìë™ ê´€í†µ ê³µê²©",
    healingOrbs: "íšŒë³µêµ¬ìŠ¬ ë“œë¡­",
    flameOrbs: "í™”ì—¼êµ¬ìŠ¬",
    poisonPools: "ë… ì›…ë©ì´",
    pierceCount: "ê´€í†µ ìˆ˜ +5",
    burnEffect: "ìˆ˜ë¥˜íƒ„ í™”ìƒ",
    bossDamage: "ë³´ìŠ¤ ë°ë¯¸ì§€ +40%",
    grenadeRange: "ìˆ˜ë¥˜íƒ„ ë²”ìœ„ +50%",

    g_doubleCast10: "ìˆ˜ë¥˜íƒ„ 10% ì¬ë°œë™",
    pierceFaster200: "ê´€í†µëŒ€í¬ ë°œì‚¬ê°„ê²© -200",
    powerFaster150: "ê°•ë ¥ì´ ë°œì‚¬ê°„ê²© -150",
    powerBurn80: "ê°•ë ¥ì´ 10ì´ˆê°„ ì´ˆë‹¹ 80 í™”ìƒ",
    powerExtraBullet20: "ê°•ë ¥ì´ 20% ì¶”ê°€ íƒ„í™˜",
    basicMega005: "ê·¹ëŒ€ íƒ„(ì´ˆê±°ëŒ€ ê´€í†µíƒ„)",
    buffGrenadePlus100: "ë²„í”„ë°œë™ ìˆ˜ë¥˜íƒ„ +100 í”¼í•´",
    grenadePlus200And10pctHP: "ìˆ˜ë¥˜íƒ„ +200, ë¹„ë³´ìŠ¤ 10% ì¶”ê°€",
    safeguard5s: "2ì´ˆë‚´ 3í”¼ê²© ì‹œ 5ì´ˆ ë¬´ì /ì´ì†2ë°°",
    swordEvery10s: "í˜¼ì˜ ê²€(ê°€ì‹œì„±â†‘, ë²”ìœ„â†‘)",
    score15On1pct: "ì²˜ì¹˜ 1% í™•ë¥  ì ìˆ˜ 1.5ë°°",
    powerRadial10s: "10ì´ˆë§ˆë‹¤ 8ë°©í–¥ ê°•ë ¥ì´",
    grenadePlus50OnDOT: "DOT ëŒ€ìƒ ìˆ˜ë¥˜íƒ„ +50",
    powerKnockback: "ê°•ë ¥ì´ í”¼ê²© ë°€ì³ë‚´ê¸°",
    basicInstakillRare: "ì‹ ì˜ íƒ„í™˜(ê·¹ì €í™•ë¥  ì¦‰ì‚¬)",
    basicPlus35: "íƒ„ë‘ ì¦ëŸ‰ +100",
    pierceCrit20: "ê´€í†µ ì¹˜ëª… 20%(x1.5, í‘œì‹œ)",

    // íŠ¹ë³„ ë…¸ë‘ ë²„í”„
    gravityField: "ì¤‘ë ¥ì¥ (ì  ì†ë„ -25%, ì´ˆë‹¹ 60 ë°ë¯¸ì§€)",
    scoreDamageBoost: "ìŠ¤ì½”ì–´ ë°ë¯¸ì§€ ë¶€ìŠ¤íŠ¸ (2000ì ë‹¹ 0.5%)",
    lifeSteal: "ìƒëª…ë ¥ í¡ìˆ˜ (1% í™•ë¥ )",
    pierceSlow: "ê´€í†µ ìŠ¬ë¡œìš° (3ì´ˆê°„ -10%)",
    powerGrenadeDrop: "ê°•ë ¥ì´ ìˆ˜ë¥˜íƒ„ ë“œë¡­",
    catPet: "ê³ ì–‘ì´ í« (4ì´ˆë§ˆë‹¤ ìˆ˜ë¥˜íƒ„)",
    valkyrieCurse: "ë°œí‚¤ë¦¬ì˜ ì €ì£¼ (í”¼í•´ +10%)",
    basicBurst: "ê¸°ë³¸ì´ ë²„ìŠ¤íŠ¸ (30ë°œë§ˆë‹¤ 10ë°œ)",
    powerSpeedCrit: "ê°•ë ¥ì´ ì†ë„+ì¹˜ëª…íƒ€",
    grenadeChain: "ìˆ˜ë¥˜íƒ„ ì—°ì‡„í­ë°œ",
    
    // ì‹ ê·œ ë…¸ë‘ ë²„í”„
    valkyrieBlessing: "ë°œí‚¤ë¦¬ì˜ ì¶•ë³µ (ê°•ë ¥ì´ 10ì—°ì†ì‹œ ë°œë™)",
    powerSmallBullet: "ê°•ë ¥ì´ ì‘ì€ ì¶”ê°€ íƒ„í™˜",
    superCritical: "ê°•ë ¥ ì¹˜ëª…íƒ€ (2.5ë°° ë°ë¯¸ì§€)",
    pierceEnhanced: "ê´€í†µëŒ€í¬ ê°•í™” íƒ„í™˜ (í™”ì—¼ í­ë°œ)",
    dogPet: "ê°•ì•„ì§€ í« (ëœë¤ íƒ„í™˜ ë°œì‚¬)",
    dotBoost: "DOT ì¶”ê°€ ë°ë¯¸ì§€ (+100)",
    basicCritical: "ê¸°ë³¸ì´ ì¹˜ëª…íƒ€ (2.5% í™•ë¥ )",

    // í”„ë¦¬ì¦˜ ë²„í”„
    basicAwakening: "ê¸°ë³¸ì´ ê°ì„± (ë°ë¯¸ì§€+25, ì†ë„+100, ë°œì‚¬ê°„ê²©-15, 35ë°œë§ˆë‹¤ ëœë¤ íƒ„í™˜)",
    powerAwakening: "ê°•ë ¥ì´ ê°ì„± (ë°ë¯¸ì§€+200, ë°œì‚¬ê°„ê²©-150, ì²´ë ¥2% ì¶”ê°€í”¼í•´)",
    pierceAwakening: "ê´€í†µëŒ€í¬ ê°ì„± (ë°ë¯¸ì§€+100, ì†ë„+100, ê´€í†µì™„ë£Œì‹œ ìˆ˜ë¥˜íƒ„)",
    grenadeAwakening: "ìˆ˜ë¥˜íƒ„ ê°ì„± (ë°ë¯¸ì§€+500, ìŠ¬ë¡œìš°15%, ì ìˆ˜ë‹¹+1.5%í”¼í•´)",
    playerAwakening: "í”Œë ˆì´ì–´ ê°ì„± (ë°›ëŠ”í”¼í•´-20%, ì…íˆëŠ”í”¼í•´+20%, 100ê±°ë¦¬ë‹¹+1ì²´ë ¥)",
    
    // ë§ˆìŠ¤í„° ë²„í”„
    basicEnhancedBullets: "ê¸°ë³¸ì´ ê°•í™” íƒ„í™˜ (ë°ë¯¸ì§€+100, ì—°ì†íƒ€ê²©ì‹œ+1%í”¼í•´)",
    powerRapidFire: "ê°•ë ¥ì´ ì—°ì‚¬ (ë°œì‚¬ê°„ê²©-200, ë¬´ê¸°ì „í™˜ì‹œ ì´ì†+50%)",
    piercePenetration: "ê´€í†µëŒ€í¬ ê´€í†µë ¥ (ì†ë„+100, ì²´ë ¥1% ì¶”ê°€í”¼í•´)"
  };

  const cardData = [
    { id: 'grenadeCooldown', title: 'í­ë°œ ë§ˆìŠ¤í„°', desc: 'ìˆ˜ë¥˜íƒ„ ì¿¨íƒ€ì„ì´ 1ì´ˆë¡œ ê°ì†Œí•©ë‹ˆë‹¤.' },
    { id: 'pierceSize', title: 'ê±°ëŒ€ í¬íƒ„', desc: 'ê´€í†µëŒ€í¬ì˜ ì´ì•Œ í¬ê¸°ê°€ ì»¤ì§‘ë‹ˆë‹¤.' },
    { id: 'zombieExplode', title: 'ì—°ì‡„ í­ë°œ', desc: 'ì¢€ë¹„ë¥¼ ì£½ì¼ ë•Œ ì‘ì€ ë²”ìœ„ë¡œ ìˆ˜ë¥˜íƒ„ì´ í„°ì§‘ë‹ˆë‹¤.' },
    { id: 'speedDodge', title: 'ì‹ ì† íšŒí”¼', desc: 'ì´ë™ì†ë„ 1.5ë°° + 15% í™•ë¥ ë¡œ íšŒí”¼ì‹œ ìˆ˜ë¥˜íƒ„ 3ê°œ ë°œì‚¬' },
    { id: 'doubleHealth', title: 'ê°•í™” ì²´ë ¥', desc: 'í”Œë ˆì´ì–´ ì²´ë ¥ì´ 2ë°°ê°€ ë©ë‹ˆë‹¤.' },
    { id: 'autoPierce', title: 'ìë™ ë°©ì–´', desc: '10ì´ˆë§ˆë‹¤ 8ë°©í–¥ìœ¼ë¡œ ê´€í†µëŒ€í¬ê°€ ë°œì‚¬ë©ë‹ˆë‹¤.' },
    { id: 'healingOrbs', title: 'ìƒëª…ì˜ êµ¬ìŠ¬', desc: 'ì¢€ë¹„ ì²˜ì¹˜ ì‹œ 2.5% í™•ë¥ ë¡œ íšŒë³µêµ¬ìŠ¬ ë“œë¡­(50 íšŒë³µ).' },
    { id: 'flameOrbs', title: 'í™”ì—¼ ë°©ì–´', desc: 'í”Œë ˆì´ì–´ ì£¼ë³€ì— í™”ì—¼êµ¬ìŠ¬ì´ ì ì„ ê³µê²©.' },
    { id: 'poisonPools', title: 'ë…ì„± ì§€ëŒ€', desc: '15ì´ˆë§ˆë‹¤ ë²”ìœ„ 3ë°°ì˜ ë… ì›…ë©ì´ ìƒì„±.' },
    { id: 'pierceCount', title: 'ê´€í†µ ê°•í™”', desc: 'ê´€í†µëŒ€í¬ì˜ ê´€í†µ ê°€ëŠ¥ ìˆ˜ê°€ 5 ì¦ê°€.' },
    { id: 'burnEffect', title: 'í™”ìƒ íš¨ê³¼', desc: 'ìˆ˜ë¥˜íƒ„ DOT: 50+ì²´ë ¥ì˜ 5%/s.' },
    { id: 'bossDamage', title: 'ë³´ìŠ¤ í‚¬ëŸ¬', desc: 'ë³´ìŠ¤ ëŒ€ìƒ í”¼í•´ 1.4ë°°.' },
    { id: 'grenadeRange', title: 'ê´‘ì—­ í­ë°œ', desc: 'ìˆ˜ë¥˜íƒ„ í­ë°œ ë²”ìœ„ 1.5ë°°.' },

    { id: 'g_doubleCast10', title: 'ì´ì¤‘ ê¸°í­', desc: 'ìˆ˜ë¥˜íƒ„ ì‚¬ìš© ì‹œ 10% í™•ë¥ ë¡œ í•œ ë²ˆ ë” ì‚¬ìš©.' },
    { id: 'pierceFaster200', title: 'ê²½ëŸ‰ ì°¨ì§€', desc: 'ê´€í†µëŒ€í¬ ë°œì‚¬ ê°„ê²© 200 ê°ì†Œ.' },
    { id: 'powerFaster150', title: 'ê°œì¡° íŠ¸ë¦¬ê±°', desc: 'ê°•ë ¥ì´ ë°œì‚¬ ê°„ê²© 150 ê°ì†Œ.' },
    { id: 'powerBurn80', title: 'ì†Œì´ ì½”ì–´', desc: 'ê°•ë ¥ì´ í”¼ê²© ì  10ì´ˆê°„ ì´ˆë‹¹ 80 í”¼í•´.' },
    { id: 'powerExtraBullet20', title: 'ë”ë¸” ë°°ëŸ´', desc: 'ê°•ë ¥ì´ 20% í™•ë¥ ë¡œ ì¶”ê°€ íƒ„í™˜.' },
    { id: 'basicMega005', title: 'ê·¹ëŒ€ íƒ„', desc: 'ê¸°ë³¸ì´ 0.5% í™•ë¥  ì´ˆê±°ëŒ€ 40x ê´€í†µíƒ„.' },
    { id: 'buffGrenadePlus100', title: 'ì¶©ê²© ì¦í­', desc: 'ë²„í”„ë°œë™ ìˆ˜ë¥˜íƒ„ í”¼í•´ +100.' },
    { id: 'grenadePlus200And10pctHP', title: 'ê³¼ì¶©ì „ í­íƒ„', desc: 'ìˆ˜ë¥˜íƒ„ +200, ë¹„ë³´ìŠ¤ ì  ì²´ë ¥ 10% ì¶”ê°€ í”¼í•´.' },
    { id: 'safeguard5s', title: 'ë¬´ì  ì§ˆì£¼', desc: '2ì´ˆë‚´ 3í”¼ê²© ì‹œ 5ì´ˆ ë¬´ì /ì´ì†2ë°°(ì”ìƒ).' },
    { id: 'swordEvery10s', title: 'í˜¼ì˜ ê²€', desc: '10ì´ˆë§ˆë‹¤ ì „ë°© ê²€(ê°€ì‹œì„±â†‘, ì†ë„â†“, ë²”ìœ„â†‘).' },
    { id: 'score15On1pct', title: 'í–‰ìš´ì˜ ì½”ì¸', desc: 'ì²˜ì¹˜ 1% í™•ë¥ ë¡œ ì ìˆ˜ 1.5ë°°.' },
    { id: 'powerRadial10s', title: 'ì´ˆì‹ ì„± í­ê²©', desc: '10ì´ˆë§ˆë‹¤ 8ë°©í–¥ ê°•ë ¥ì´ ë°œì‚¬.' },
    { id: 'grenadePlus50OnDOT', title: 'ìƒì²˜ ë²Œë¦¬ê¸°', desc: 'DOT ëŒ€ìƒì—ê²Œ ìˆ˜ë¥˜íƒ„ í”¼í•´ +50.' },
    { id: 'powerKnockback', title: 'ì¶©ê²© ì™„ì¶©', desc: 'ê°•ë ¥ì´ í”¼ê²© ì‹œ ì  ì•½ê°„ ë°€ì¹¨.' },
    { id: 'basicInstakillRare', title: 'ì‹ ì˜ íƒ„í™˜', desc: 'ê¸°ë³¸ì´ 0.06% í™•ë¥  ì¦‰ì‚¬íƒ„.' },
    { id: 'basicPlus35', title: 'íƒ„ë‘ ì¦ëŸ‰', desc: 'ê¸°ë³¸ì´ í”¼í•´ +100.' },
    { id: 'pierceCrit20', title: 'ê´€í†µ ì¹˜ëª…', desc: 'ê´€í†µëŒ€í¬ ì¹˜ëª…íƒ€ 20%(x1.5, "í¬ë¦¬í‹°ì»¬!" í‘œì‹œ).' },

    // íŠ¹ë³„ ë…¸ë‘ ë²„í”„ ì¹´ë“œ
    { id: 'gravityField', title: 'ì¤‘ë ¥ì¥', desc: 'í”Œë ˆì´ì–´ ì£¼ë³€ ì¤‘ë ¥ì¥ìœ¼ë¡œ ì  ì†ë„ 25% ê°ì†Œ, ì´ˆë‹¹ 60 ë°ë¯¸ì§€.', color: '#fbbf24' },
    { id: 'scoreDamageBoost', title: 'ìŠ¤ì½”ì–´ íŒŒì›Œ', desc: '2000ì ë‹¹ ëª¨ë“  í”¼í•´ 0.5% ì¦ê°€.', color: '#fbbf24' },
    { id: 'lifeSteal', title: 'ìƒëª…ë ¥ í¡ìˆ˜', desc: 'ì¢€ë¹„ í”¼í•´ ì‹œ 1% í™•ë¥ ë¡œ ì²´ë ¥ 10 íšŒë³µ.', color: '#fbbf24' },
    { id: 'pierceSlow', title: 'ê´€í†µ ìŠ¬ë¡œìš°', desc: 'ê´€í†µëŒ€í¬ í”¼ê²© ì‹œ 3ì´ˆê°„ ì†ë„ 10% ê°ì†Œ.', color: '#fbbf24' },
    { id: 'powerGrenadeDrop', title: 'ê°•ë ¥ í­ë°œ', desc: 'ê°•ë ¥ì´ìœ¼ë¡œ ì  ì²˜ì¹˜ ì‹œ ìˆ˜ë¥˜íƒ„ 2ê°œ ë“œë¡­.', color: '#fbbf24' },
    { id: 'catPet', title: 'ê³ ì–‘ì´ í«', desc: '4ì´ˆë§ˆë‹¤ ì¢€ë¹„ ë°€ì§‘ì§€ì—­ì— ìˆ˜ë¥˜íƒ„ íˆ¬í•˜.', color: '#fbbf24' },
    { id: 'valkyrieCurse', title: 'ë°œí‚¤ë¦¬ì˜ ì €ì£¼', desc: 'ê°•ë ¥ì´ í”¼ê²© ì‹œ ë¬´í•œ í”¼í•´ 10% ì¦ê°€.', color: '#fbbf24' },
    { id: 'basicBurst', title: 'ê¸°ë³¸ì´ ë²„ìŠ¤íŠ¸', desc: '30ë°œ ë°œì‚¬ë§ˆë‹¤ 10ë°œ ì¶”ê°€ ë°œì‚¬.', color: '#fbbf24' },
    { id: 'powerSpeedCrit', title: 'ê°•ë ¥ì´ ê°•í™”', desc: 'ì†ë„ +100, ì¹˜ëª…íƒ€ ì¶”ê°€.', color: '#fbbf24' },
    { id: 'grenadeChain', title: 'ì—°ì‡„ í­ë°œ', desc: 'ìˆ˜ë¥˜íƒ„ í­ë°œ 1ì´ˆ í›„ 3ë²ˆ ì—°ì‡„í­ë°œ.', color: '#fbbf24' },
    
    // ì‹ ê·œ ë…¸ë‘ ë²„í”„ ì¹´ë“œ
    { id: 'valkyrieBlessing', title: 'ë°œí‚¤ë¦¬ì˜ ì¶•ë³µ', desc: 'ê°•ë ¥ì´ 10ì—°ì† ì‚¬ìš©ì‹œ ë°œë™. firerate-100, ì´ì†+15%.', color: '#fbbf24' },
    { id: 'powerSmallBullet', title: 'ê°•ë ¥ì´ ì‘ì€ ì¶”ê°€ íƒ„í™˜', desc: '50% ì‘ì€ ì¶”ê°€ íƒ„í™˜ ë°œì‚¬, 50% ë°ë¯¸ì§€.', color: '#fbbf24' },
    { id: 'superCritical', title: 'ê°•ë ¥ ì¹˜ëª…íƒ€', desc: 'ëª¨ë“  ì¹˜ëª…íƒ€ì— 50% í™•ë¥ ë¡œ 2.5ë°° ë°ë¯¸ì§€.', color: '#fbbf24' },
    { id: 'pierceEnhanced', title: 'ê´€í†µëŒ€í¬ ê°•í™” íƒ„í™˜', desc: '3% í™•ë¥ ë¡œ í™”ì—¼ í­ë°œí•˜ëŠ” ê°•í™” íƒ„í™˜.', color: '#fbbf24' },
    { id: 'dogPet', title: 'ê°•ì•„ì§€ í«', desc: '7ì´ˆë§ˆë‹¤ ëœë¤ íƒ„í™˜ ë°œì‚¬ (ê³ ì–‘ì´ í«ì‹œ 4ì´ˆ).', color: '#fbbf24' },
    { id: 'dotBoost', title: 'DOT ì¶”ê°€ ë°ë¯¸ì§€', desc: 'ëª¨ë“  DOT íš¨ê³¼ì— +100 ë°ë¯¸ì§€.', color: '#fbbf24' },
    { id: 'basicCritical', title: 'ê¸°ë³¸ì´ ì¹˜ëª…íƒ€', desc: '2.5% í™•ë¥ ë¡œ 1.7ë°° ë°ë¯¸ì§€ ì¹˜ëª…íƒ€.', color: '#fbbf24' },

    // í”„ë¦¬ì¦˜ ë²„í”„ ì¹´ë“œ
    { id: 'basicAwakening', title: 'ê¸°ë³¸ì´ ê°ì„±', desc: 'ë°ë¯¸ì§€+25, ì†ë„+100, ë°œì‚¬ê°„ê²©-15, 35ë°œë§ˆë‹¤ ëœë¤ íƒ„í™˜.', color: '#8b5cf6' },
    { id: 'powerAwakening', title: 'ê°•ë ¥ì´ ê°ì„±', desc: 'ë°ë¯¸ì§€+200, ë°œì‚¬ê°„ê²©-150, ì²´ë ¥2% ì¶”ê°€í”¼í•´, í•„ìˆ˜ì¹˜ëª…íƒ€.', color: '#8b5cf6' },
    { id: 'pierceAwakening', title: 'ê´€í†µëŒ€í¬ ê°ì„±', desc: 'ë°ë¯¸ì§€+100, ì†ë„+100, ê´€í†µì™„ë£Œì‹œ ìˆ˜ë¥˜íƒ„ í­ë°œ.', color: '#8b5cf6' },
    { id: 'grenadeAwakening', title: 'ìˆ˜ë¥˜íƒ„ ê°ì„±', desc: 'ë°ë¯¸ì§€+500, ì  ìŠ¬ë¡œìš°15%, ì ìˆ˜ë‹¹+1.5%í”¼í•´ ì¦ê°€.', color: '#8b5cf6' },
    { id: 'playerAwakening', title: 'í”Œë ˆì´ì–´ ê°ì„±', desc: 'ë°›ëŠ”í”¼í•´-20%, ì…íˆëŠ”í”¼í•´+20%, 100ê±°ë¦¬ë‹¹+1ì²´ë ¥.', color: '#8b5cf6' },
    
    // ë§ˆìŠ¤í„° ë²„í”„ ì¹´ë“œ
    { id: 'basicEnhancedBullets', title: 'ê¸°ë³¸ì´ ê°•í™” íƒ„í™˜', desc: 'ë°ë¯¸ì§€+100, ì—°ì†íƒ€ê²©ì‹œ í”¼í•´+1% (ìµœëŒ€100%, ë³´ìŠ¤50%).', color: '#dc2626' },
    { id: 'powerRapidFire', title: 'ê°•ë ¥ì´ ì—°ì‚¬', desc: 'ë°œì‚¬ê°„ê²©-200, ë¬´ê¸°ì „í™˜ì‹œ 1ì´ˆê°„ ì´ì†+50% (ì¿¨10ì´ˆ).', color: '#dc2626' },
    { id: 'piercePenetration', title: 'ê´€í†µëŒ€í¬ ê´€í†µë ¥', desc: 'ì†ë„+100, ì  ì²´ë ¥1% ì¶”ê°€í”¼í•´.', color: '#dc2626' }
  ];

  // ìŠ¤í˜ì…œ ë³´ìƒ ì¹´ë“œ (ëª¨ë“  ë²„í”„ íšë“ í›„ì—ë„ ë°˜ë³µ ë“±ì¥ ê°€ëŠ¥)
  const specialRewardCards = [
    { id: 'reward_score3000', title: 'ë³´ë„ˆìŠ¤ ì ìˆ˜', desc: 'ìŠ¤ì½”ì–´ 3000ì  ì¦‰ì‹œ íšë“.' },
    { id: 'reward_heal50', title: 'ì‘ê¸‰ ì²˜ì¹˜', desc: 'í”Œë ˆì´ì–´ ì²´ë ¥ 50 íšŒë³µ.' }
  ];

  const BULLET_CAP = 1500;

  function spawnBullet(x,y,dx,dy, r=8, life=2000, color='#fff', damage=10, pierce=false, extra={}){
    if(bullets.length > BULLET_CAP) return;
    bullets.push({
      x: x||0, y: y||0, dx: dx||0, dy: dy||0, r, life,
      born: performance.now(), color, damage, pierce,
      hits: 0,
      weaponId: extra.weaponId || null,
      outline: extra.outline || null,
      maxPierceHits: extra.maxPierceHits || null,
      instantKill: !!extra.instantKill,
      isMega: !!extra.isMega,
      alpha: extra.alpha ?? 1
    });
  }

  function spawnFloatingText(text, x, y, color='#fff'){
    floatingTexts.push({ text, x, y, color, born: performance.now(), life: 800 });
  }

  function spawnBloodPool(x, y, size){
    bloodPools.push({ x, y, size, born: performance.now(), life: 600 });
  }

  function spawnGrenade(obj){ grenades.push(obj); }

  function throwGrenade(targetX,targetY,{ignoreCooldown=false, fromBuff=false}={}){
    const now = performance.now();
    if(!ignoreCooldown && (now - lastGrenade < grenadeCooldown)) return false;
    lastGrenade = now;
    const sx = player.x, sy = player.y - 6;
    const dx = targetX - sx, dy = targetY - sy;
    const dist = Math.hypot(dx,dy);
    const gravity = 1400;
    const travelTime = Math.min(1.1, Math.max(0.45, dist / 900));
    let vx = dx / travelTime;
    let vy = (dy - 0.5 * gravity * travelTime * travelTime) / travelTime;
    if(!isFinite(vx) || !isFinite(vy)){ vx = Math.sign(dx)*200; vy = -300; }
    const baseRange = 110;
    const range = buffs.grenadeRange ? Math.round(baseRange * 1.5) : baseRange;
    const baseDamage = 340 + (buffs.grenadePlus200And10pctHP ? 200 : 0); // ìˆ˜ë¥˜íƒ„ ê¸°ë³¸ 340
    spawnGrenade({ x: sx, y: sy, vx, vy, born: now, fuse: Math.ceil(travelTime*1000 + 200), explodeRadius: range, damage: baseDamage, targetX, targetY, fromBuff });
    return true;
  }

  function maybeQueueExtraGrenade(targetX, targetY){
    if(!buffs.g_doubleCast10) return;
    if(Math.random() < 0.10){
      queuedGrenades.push({ targetX, targetY, fromBuff: true });
    }
  }

  function processQueuedGrenades(){
    if(queuedGrenades.length === 0) return;
    const next = queuedGrenades.shift();
    // ë²„í”„ ìˆ˜ë¥˜íƒ„ì€ ì§ì ‘ ìƒì„± (í”Œë ˆì´ì–´ ì¿¨íƒ€ì„ì— ì˜í–¥ ì—†ìŒ)
    if(next.fromBuff){
      const baseRange = 110;
      const range = buffs.grenadeRange ? Math.round(baseRange * 1.5) : baseRange;
      const baseDamage = 340 + (buffs.grenadePlus200And10pctHP ? 200 : 0);
      spawnGrenade({ x: player.x, y: player.y - 6, vx: 0, vy: 0, born: performance.now(), fuse: 200, explodeRadius: range, damage: baseDamage, fromBuff: true, isQueuedGrenade: true });
    } else {
      throwGrenade(next.targetX, next.targetY, { ignoreCooldown: true, fromBuff: next.fromBuff });
    }
  }

  function spawnZombie(){
    const edge = Math.random();
    const z = { r: Math.floor(rand(12,20)), speed: rand(18,45), hp: 1, colorPhase: Math.random() };
    if(edge < 0.5){ z.x = rand(20, W-20); z.y = -30; }
    else if(edge < 0.75){ z.x = -30; z.y = rand(20, H-120); }
    else { z.x = W+30; z.y = rand(20, H-120); }
    // ì²´ë ¥ ì¦ê°€ ì†ë„ 1.5ë°° ê°€ì¤‘ + ë‹¨ê³„ì  ë‚œì´ë„ ì¦ê°€
    z.hp = Math.ceil(rand(1, 2 + (score/200)*1.5) * getLateGameMultiplier());
    z.burnTime = 0;        // ì¼ë°˜ ìˆ˜ë¥˜íƒ„ í™”ìƒ ì‹œê°„(ms)
    z.poisonedTime = 0;    // ë… ìƒíƒœ ì‹œê°„(ms)
    z.powerBurnTime = 0;   // ê°•ë ¥ì´ í™”ìƒ ì‹œê°„(ms)
    
    // 2% í™•ë¥ ë¡œ í­íƒ„ ì¢€ë¹„ ìƒì„±
    if(Math.random() < 0.02){
      z.isBomb = true;
      z.color = '#ff4444'; // ë¹¨ê°„ìƒ‰ìœ¼ë¡œ êµ¬ë¶„
    }
    
    zombies.push(z);
  }

  function spawnBoss(){
    const base = 3000 + Math.floor((score/2)*1.5); // ë³´ìŠ¤ ì²´ë ¥ ì¦ê°€ 1.5ë°° ê°€ì¤‘
    const hp = Math.ceil(base * getLateGameMultiplier()); // ë‹¨ê³„ì  ë‚œì´ë„ ì¦ê°€
    const b = { x: Math.random()*(W-200)+100, y: rand(50, H/2), r: 48, hp, maxHp: hp, speed: 18, attackCooldown: 0, warningTime: 0, isWarning:false, isMutant:false };
    bosses.push(b);
    flashTime = 160; flashX = b.x; flashY = b.y; flashR = 60; cameraShake = 18;
  }

  function spawnMutantBoss(){
    const refBase = 3000 + Math.floor((score/2)*1.5);
    const hp = Math.ceil(refBase * 4 * getLateGameMultiplier()); // ë‹¨ê³„ì  ë‚œì´ë„ ì¦ê°€
    const b = { x: Math.random()*(W-200)+100, y: rand(50, H/2), r: 96, hp, maxHp: hp, speed: 18, attackCooldown: 0, warningTime: 0, isWarning:false, isMutant:true };
    bosses.push(b);
    flashTime = 200; flashX = b.x; flashY = b.y; flashR = 90; cameraShake = 22;
  }

  function applyWeaponBuffs(){
    // reset to base
    for(let i=0;i<weapons.length;i++){
      const base = BASE_WEAPONS[i];
      weapons[i] = { ...weapons[i], ...base };
    }
    
    // ê¸°ë³¸ì´ +100 (íƒ„ë‘ ì¦ëŸ‰)
    if(buffs.basicPlus35){
      weapons[0].damage += 100;
    }
    
    // ê¸°ë³¸ì´ ê°ì„±
    if(buffs.basicAwakening){
      weapons[0].damage += 25;
      weapons[0].bulletSpeed += 100;
      weapons[0].fireRate = Math.max(100, weapons[0].fireRate - 15);
    }
    
    // ê°•ë ¥ì´ ê°ì„±
    if(buffs.powerAwakening){
      weapons[1].damage += 200;
      weapons[1].fireRate = Math.max(100, weapons[1].fireRate - 150);
    }
    
    // ê´€í†µëŒ€í¬ ê°ì„±
    if(buffs.pierceAwakening){
      weapons[2].damage += 100;
      weapons[2].bulletSpeed += 100;
    }
    
    // ê´€í†µëŒ€í¬ ê´€í†µë ¥: ì†ë„ +100
    if(buffs.piercePenetration){
      weapons[2].bulletSpeed += 100;
    }
    
    // ê´€í†µëŒ€í¬ -200 fireRate
    if(buffs.pierceFaster200){
      weapons[2].fireRate = Math.max(100, weapons[2].fireRate - 200);
    }
    // ê°•ë ¥ì´ -150 fireRate
    if(buffs.powerFaster150){
      weapons[1].fireRate = Math.max(100, weapons[1].fireRate - 150);
    }
    
    // ë°œí‚¤ë¦¬ì˜ ì¶•ë³µ: ê°•ë ¥ì´ fireRate -100
    if(valkyrieBlessingActive && buffs.valkyrieBlessing){
      weapons[1].fireRate = Math.max(100, weapons[1].fireRate - 100);
    }
    
    // ê°•ë ¥ì´ ì—°ì‚¬: fireRate -200
    if(buffs.powerRapidFire){
      weapons[1].fireRate = Math.max(100, weapons[1].fireRate - 200);
    }
  }

  function updateWeaponStats(){
    applyWeaponBuffs();
    const w = weapons[currentWeapon];
    player.fireRate = w.fireRate;
    weaponNameEl.textContent = w.name;
  }

  function reset(){
    score = 0; player.x = W/2; player.y = H-80;
    player.health = 100; player.maxHealth = 100;
    bullets = []; zombies = []; bosses = []; cards = [];
    flameOrbs = []; poisonPools = []; healingOrbs = [];
    floatingTexts = []; bloodPools = [];
    grenades = []; queuedGrenades = [];
    spawnInterval = 1200; spawnTimer = difficultyTimer = bossTimer = mutantTimer = 0;
    running = true; lastGrenade = -99999; currentWeapon = 0;
    grenadeCooldown = 5000; autoShootTimer = 0; poisonTimer = 0; flameOrbAngle = 0;
    powerBurstTimer = 0; swordTimer = 0; safeguardWindow = []; safeguardActive = false; safeguardUntil = 0;
    cardPicksRemaining = 0; specialRewardMode = false;
    
    // íŠ¹ë³„ ë²„í”„ ë³€ìˆ˜ ì´ˆê¸°í™”
    catPetTimer = 0; basicShotCount = 0; chainExplosions = []; slowedEnemies = []; cursedEnemies = [];
    valkyrieBlessingActive = false; powerShotCount = 0; dogPetTimer = 0; flameExplosions = []; flamePools = [];
    playerDistance = 0; lastPlayerX = player.x; lastPlayerY = player.y;
    enhancedBulletHits.clear(); powerWeaponSwitchTimer = 0; powerWeaponSwitchCooldown = 0;
    
    // ê²Œì„ ì‹œê°„ ì´ˆê¸°í™”
    gameStartTime = performance.now();
    isLateGame = false;
    
    // í†µê³„ ì´ˆê¸°í™”
    weaponDamage = { basic: 0, power: 0, pierce: 0 };
    updateHighScoresDisplay();

    Object.keys(buffs).forEach(key => buffs[key] = false);
    applyWeaponBuffs();
    updateWeaponStats();
    updateBuffDisplay();
    updateHealthDisplay();
    overlay.style.display = 'none';
    cardOverlay.style.display = 'none';
    startOverlay.style.display = 'block';
    running = false;
  }

  function cleanupBullets(){
    const now = performance.now();
    bullets = bullets.filter(b => b && typeof b.born === 'number' && (now - b.born) < (b.life || 0));
  }

  function explodeGrenade(g, isZombieExplode = false){
    if(!g) return;
    try{
      const radius = isZombieExplode ? 60 : g.explodeRadius;
      let baseDamage = isZombieExplode ? 60 : g.damage;
      
      // ìˆ˜ë¥˜íƒ„ ê°ì„±: ë°ë¯¸ì§€ +500
      if(buffs.grenadeAwakening && !isZombieExplode){
        baseDamage += 500;
      }
      
      // ì‹œê° íš¨ê³¼
      flashTime = 200; flashX = g.x; flashY = g.y; flashR = radius; cameraShake = Math.max(cameraShake, 10);

      // zombies
      let enemyCount = 0;
      for(let i = zombies.length-1; i>=0; --i){
        const z = zombies[i]; if(!z) continue;
        const d = Math.hypot(z.x - g.x, z.y - g.y);
        if(d <= radius + z.r){
          enemyCount++;
        }
      }
      
      // ë³´ìŠ¤ë„ ì¹´ìš´íŠ¸ì— í¬í•¨
      for(let i = bosses.length-1; i>=0; --i){
        const b = bosses[i]; if(!b) continue;
        const d = Math.hypot(b.x - g.x, b.y - g.y);
        if(d <= radius + b.r){
          enemyCount++;
        }
      }
      
      for(let i = zombies.length-1; i>=0; --i){
        const z = zombies[i]; if(!z) continue;
        const d = Math.hypot(z.x - g.x, z.y - g.y);
        if(d <= radius + z.r){
          let dmg = baseDamage;
          if(!isZombieExplode){
            if(buffs.buffGrenadePlus100 && g.fromBuff) dmg += 100;
            if(buffs.grenadePlus50OnDOT && (z.burnTime>0 || z.poisonedTime>0 || z.powerBurnTime>0)) dmg += 50;
            
            // ìˆ˜ë¥˜íƒ„ ê°ì„±: ì  ìˆ˜ë‹¹ 1.5% í”¼í•´ ì¦ê°€
            if(buffs.grenadeAwakening){
              dmg *= (1 + enemyCount * 0.015);
            }
          }
          // ê¸°ë³¸ ë°ë¯¸ì§€ í™˜ì‚°
          let hitDamage = Math.ceil(dmg / 10);
          // ë¹„ë³´ìŠ¤ 10% ì¶”ê°€
          if(buffs.grenadePlus200And10pctHP && !isZombieExplode){
            hitDamage += Math.ceil(z.hp * 0.10);
          }
          z.hp -= hitDamage;
          
          // ìˆ˜ë¥˜íƒ„ ê°ì„±: ìŠ¬ë¡œìš° íš¨ê³¼ (15% ëŠë ¤ì§)
          if(buffs.grenadeAwakening && !isZombieExplode){
            if(!slowedEnemies.find(se => se.enemy === z)){
              const originalSpeed = z.speed;
              z.speed *= 0.85; // 15% ê°ì†Œ
              slowedEnemies.push({ enemy: z, originalSpeed, timer: 5000 }); // 5ì´ˆê°„ ì§€ì†
            }
          }
          if(z.hp <= 0){
            let add = Math.ceil(12 + z.r + z.speed/3);
            if(buffs.score15On1pct && Math.random() < 0.01) add = Math.ceil(add * 1.5);
            score += add;
            
            // í­íƒ„ ì¢€ë¹„ í­ë°œ ì²˜ë¦¬
            if(z.isBomb){
              const dist = Math.hypot(z.x - player.x, z.y - player.y);
              if(dist < 60){ // í­ë°œ ë²”ìœ„ 60
                if(!safeguardActive){
                  let damage = 35;
                  
                  // í”Œë ˆì´ì–´ ê°ì„±: ë°›ëŠ” í”¼í•´ 20% ê°ì†Œ
                  if(buffs.playerAwakening){
                    damage *= 0.8;
                  }
                  
                  player.health -= damage;
                  spawnFloatingText('í­ë°œ! -' + Math.ceil(damage), player.x, player.y-20, '#ff4444');
                  cameraShake = 8;
                  if(player.health <= 0){ 
                    player.health = 0; 
                    running = false; 
                    showOverlay('Game Over','í´ë¦­í•˜ê±°ë‚˜ ì¬ì‹œì‘ ë²„íŠ¼ìœ¼ë¡œ ì¬ì‹œì‘'); 
                  }
                }
                // í­ë°œ ì´í™íŠ¸
                flashTime = 100; flashX = z.x; flashY = z.y; flashR = 60;
              }
            }
            
            // í”¼ ì›…ë©ì´ ìƒì„± (ì¢€ë¹„ í¬ê¸°ì— ë¹„ë¡€)
            spawnBloodPool(z.x, z.y, z.r);
            
            for(let p=0;p<4;p++){
              const a=Math.random()*Math.PI*2;
              spawnBullet(z.x,z.y,Math.cos(a)*rand(90,240),Math.sin(a)*rand(90,240));
            }
            zombies.splice(i,1);
          }else if(buffs.burnEffect && !isZombieExplode){
            z.burnTime = 10000;
          }
        }
      }

      // bosses
      for(let i = bosses.length-1; i>=0; --i){
        const b = bosses[i]; if(!b) continue;
        const d = Math.hypot(b.x - g.x, b.y - g.y);
        if(d <= radius + b.r){
          let dmg = baseDamage;
          if(!isZombieExplode){
            if(buffs.buffGrenadePlus100 && g.fromBuff) dmg += 100;
            // DOT ì¶”ê°€ +50ì€ ë³´ìŠ¤ì—” ë¯¸ì ìš©(ëª…ì„¸ê°€ ë¹„ë³´ìŠ¤ ìœ„ì£¼)
            
            // ìˆ˜ë¥˜íƒ„ ê°ì„±: ì  ìˆ˜ë‹¹ 1.5% í”¼í•´ ì¦ê°€
            if(buffs.grenadeAwakening){
              dmg *= (1 + enemyCount * 0.015);
            }
          }
          if(buffs.bossDamage) dmg *= 1.4;
          b.hp -= dmg;
          
          // ìˆ˜ë¥˜íƒ„ ê°ì„±: ë³´ìŠ¤ë„ ìŠ¬ë¡œìš° íš¨ê³¼ (15% ëŠë ¤ì§)
          if(buffs.grenadeAwakening && !isZombieExplode){
            if(!slowedEnemies.find(se => se.enemy === b)){
              const originalSpeed = b.speed;
              b.speed *= 0.85; // 15% ê°ì†Œ
              slowedEnemies.push({ enemy: b, originalSpeed, timer: 5000 }); // 5ì´ˆê°„ ì§€ì†
            }
          }
          if(b.hp <= 0){
            score += 500;
            // ë“œë: ëŒì—°ë³€ì´ë©´ 2í”½, ì¼ë°˜ì´ë©´ 1í”½
            spawnCard(b.x, b.y, b.isMutant ? 2 : 1);
            bosses.splice(i,1);
            cameraShake = 18;
          }
        }
      }

      // í­ë°œ íŒŒí¸ ì´í™íŠ¸
      if(!isZombieExplode){
        for(let i=0;i<12;i++){
          const a=Math.random()*Math.PI*2;
          spawnBullet(g.x,g.y,Math.cos(a)*rand(120,360),Math.sin(a)*rand(120,360),4,700,'#ff6b6b',0);
        }
        
        // ì—°ì‡„ í­ë°œ (1ì´ˆ í›„ 3ë²ˆ) - ì¼ë°˜ ìˆ˜ë¥˜íƒ„ í­ë°œì—ì„œë§Œ ë°œìƒ (ê³ ì–‘ì´ í« ì œì™¸)
        if(buffs.grenadeChain && !g.isChainExplosion && !g.isCatPet){
          chainExplosions.push({ x: g.x, y: g.y, timer: 1000 });
          chainExplosions.push({ x: g.x, y: g.y, timer: 1000 });
          chainExplosions.push({ x: g.x, y: g.y, timer: 1000 });
        }
      }
    }catch(e){ console.error('explodeGrenade error', e); }
  }

  function spawnCard(x, y, picks=1){
    cards.push({ x, y, r: 12, color: '#8b5cf6', collected: false, picks });
  }

  function spawnHealingOrb(x, y){
    healingOrbs.push({ x, y, r: 8, color: '#10b981', life: 10000, born: performance.now() });
  }

  function allNormalBuffsAcquired(){
    const normalBuffIds = Object.keys(buffs).filter(id => !id.startsWith('gravityField') && !id.startsWith('scoreDamageBoost') && !id.startsWith('lifeSteal') && !id.startsWith('pierceSlow') && !id.startsWith('powerGrenadeDrop') && !id.startsWith('catPet') && !id.startsWith('valkyrieCurse') && !id.startsWith('basicBurst') && !id.startsWith('powerSpeedCrit') && !id.startsWith('grenadeChain'));
    for(const id of normalBuffIds){
      if(!buffs[id]) return false;
    }
    return true;
  }

  function getAcquiredBuffCount(){
    return Object.values(buffs).filter(acquired => acquired).length;
  }

  function showCardSelection({picks=1, forceSpecial=false} = {}){
    // ê²Œì„ ì¼ì‹œì •ì§€
    running = false;
    
    cardOverlay.style.display = 'block';
    cardContainer.innerHTML = '';
    specialRewardMode = forceSpecial || allNormalBuffsAcquired();
    cardPicksRemaining = picks;
    cardTitle.textContent = specialRewardMode ? 'íŠ¹ë³„ ë³´ìƒ ì„ íƒ!' : 'ì¹´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”!';
    pickHint.textContent = picks > 1 ? `ì´ë²ˆì—” ${picks}ê°œë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.` : '';

    let options = [];
    if(specialRewardMode){
      options = specialRewardCards;
    }else{
      const availableCards = cardData.filter(card => !buffs[card.id]);
      const shuffled = [...availableCards].sort(() => Math.random() - 0.5);
      
      // 10ê°œ ì´ìƒ ë²„í”„ íšë“ ì‹œ í™•ë¥ ë³„ ë²„í”„ ì¶”ê°€
      if(getAcquiredBuffCount() >= 10){
        const random = Math.random();
        if(random < 0.08){
          // 8% í™•ë¥ ë¡œ ë§ˆìŠ¤í„° ë²„í”„ (ìµœê³  ë“±ê¸‰)
          const masterCards = availableCards.filter(card => card.color === '#dc2626');
          if(masterCards.length > 0){
            const masterCard = masterCards[Math.floor(Math.random() * masterCards.length)];
            options = [masterCard, ...shuffled.slice(0, 2)];
          } else {
            options = shuffled.slice(0, 3);
          }
        } else if(random < 0.18){
          // 10% í™•ë¥ ë¡œ í”„ë¦¬ì¦˜ ë²„í”„
          const prismCards = availableCards.filter(card => card.color === '#8b5cf6');
          if(prismCards.length > 0){
            const prismCard = prismCards[Math.floor(Math.random() * prismCards.length)];
            options = [prismCard, ...shuffled.slice(0, 2)];
          } else {
            options = shuffled.slice(0, 3);
          }
        } else if(random < 0.48){
          // 30% í™•ë¥ ë¡œ íŠ¹ë³„ ë…¸ë‘ ë²„í”„
          const specialCards = availableCards.filter(card => card.color === '#fbbf24');
          if(specialCards.length > 0){
            const specialCard = specialCards[Math.floor(Math.random() * specialCards.length)];
            options = [specialCard, ...shuffled.slice(0, 2)];
          } else {
            options = shuffled.slice(0, 3);
          }
        } else {
          options = shuffled.slice(0, 3);
        }
      } else {
        options = shuffled.slice(0, 3);
      }
    }

    options.forEach(card => {
      const cardEl = document.createElement('div');
      cardEl.className = 'card';
      if(card.color === '#fbbf24'){
        cardEl.style.borderColor = '#fbbf24';
        cardEl.style.boxShadow = '0 0 20px rgba(251, 191, 36, 0.5)';
      } else if(card.color === '#8b5cf6'){
        cardEl.style.borderColor = '#8b5cf6';
        cardEl.style.boxShadow = '0 0 30px rgba(139, 92, 246, 0.8), 0 0 60px rgba(139, 92, 246, 0.4), inset 0 0 20px rgba(139, 92, 246, 0.2)';
        cardEl.style.background = 'linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(168, 85, 247, 0.1))';
        cardEl.style.borderWidth = '3px';
        cardEl.style.borderStyle = 'solid';
        cardEl.style.borderImage = 'linear-gradient(45deg, #8b5cf6, #a855f7, #c084fc, #8b5cf6) 1';
      } else if(card.color === '#dc2626'){
        // ë§ˆìŠ¤í„° ë²„í”„ íŠ¹ë³„ íš¨ê³¼
        cardEl.style.borderColor = '#dc2626';
        cardEl.style.boxShadow = '0 0 40px rgba(220, 38, 38, 1), 0 0 80px rgba(220, 38, 38, 0.6), 0 0 120px rgba(220, 38, 38, 0.3), inset 0 0 25px rgba(220, 38, 38, 0.3)';
        cardEl.style.background = 'linear-gradient(135deg, rgba(220, 38, 38, 0.2), rgba(239, 68, 68, 0.15), rgba(185, 28, 28, 0.1))';
        cardEl.style.borderWidth = '4px';
        cardEl.style.borderStyle = 'solid';
        cardEl.style.borderRadius = '10px';
        cardEl.style.animation = 'pulse 2s infinite';
        cardEl.style.position = 'relative';
        
        // ë§ˆìŠ¤í„° ë²„í”„ ê¸€ë¡œìš° íš¨ê³¼
        cardEl.style.textShadow = '0 0 10px rgba(220, 38, 38, 0.8)';
        
        // CSS ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
        if (!document.getElementById('masterBuffAnimation')) {
          const style = document.createElement('style');
          style.id = 'masterBuffAnimation';
          style.textContent = `
            @keyframes pulse {
              0% { transform: scale(1); box-shadow: 0 0 40px rgba(220, 38, 38, 1), 0 0 80px rgba(220, 38, 38, 0.6), 0 0 120px rgba(220, 38, 38, 0.3); }
              50% { transform: scale(1.02); box-shadow: 0 0 50px rgba(220, 38, 38, 1.2), 0 0 100px rgba(220, 38, 38, 0.8), 0 0 150px rgba(220, 38, 38, 0.5); }
              100% { transform: scale(1); box-shadow: 0 0 40px rgba(220, 38, 38, 1), 0 0 80px rgba(220, 38, 38, 0.6), 0 0 120px rgba(220, 38, 38, 0.3); }
            }
          `;
          document.head.appendChild(style);
        }
      }
      cardEl.innerHTML = `<div class="card-title">${card.title}</div><div class="card-desc">${card.desc}</div>`;
      cardEl.addEventListener('click', () => {
        if(specialRewardMode){
          selectSpecialReward(card.id);
        }else{
          selectCard(card.id);
        }
      });
      cardContainer.appendChild(cardEl);
    });
  }

  function selectSpecialReward(cardId){
    if(cardId === 'reward_score3000'){
      score += 3000;
    }else if(cardId === 'reward_heal50'){
      player.health = Math.min(player.maxHealth, player.health + 50);
      updateHealthDisplay();
    }
    cardPicksRemaining--;
    if(cardPicksRemaining <= 0){
      cardOverlay.style.display = 'none';
      // ê²Œì„ ì¬ê°œ
      running = true;
    }else{
      // ë‹¤ìŒ ì„ íƒì„ ìœ„í•´ ë‹¤ì‹œ ì¹´ë“œ ì œê³µ (ë™ì¼ ìŠ¤í˜ì…œ ì…‹)
      showCardSelection({picks: cardPicksRemaining, forceSpecial: true});
    }
  }

  function selectCard(cardId){
    buffs[cardId] = true;
    // ì¦‰ì‹œ ë°˜ì˜
    if(cardId === 'grenadeCooldown'){
      grenadeCooldown = 1000;
    } else if(cardId === 'doubleHealth'){
      player.maxHealth = 200;
      player.health = Math.min(player.health * 2, player.maxHealth);
    } else if(cardId === 'flameOrbs'){
      for(let i = 0; i < 3; i++){
        flameOrbs.push({ angle: (i * Math.PI * 2) / 3, distance: 40 + i * 15, r: 8 });
      }
    } else if(cardId === 'catPet'){
      // ê³ ì–‘ì´ í« ì´ˆê¸°í™”
      catPetTimer = 0;
    }
    applyWeaponBuffs();
    updateWeaponStats();
    updateBuffDisplay();
    updateHealthDisplay();

    cardPicksRemaining--;
    if(cardPicksRemaining <= 0){
      cardOverlay.style.display = 'none';
      // ê²Œì„ ì¬ê°œ
      running = true;
    }else{
      // ë‹¤ìŒ í”½: ì´ë¯¸ ê³ ë¥¸ ë²„í”„ëŠ” ì œì™¸í•˜ê³  ì¬í‘œì‹œ
      showCardSelection({picks: cardPicksRemaining});
    }
  }

  function updateBuffDisplay(){
    buffList.innerHTML = '';
    Object.keys(buffs).forEach(key => {
      if(buffs[key]){
        const buffEl = document.createElement('div');
        buffEl.className = 'buff-item';
        buffEl.textContent = buffNames[key];
        
        // ë²„í”„ ë“±ê¸‰ì— ë”°ë¥¸ í…Œë‘ë¦¬ ìƒ‰ìƒ ì„¤ì •
        if(key.includes('gravityField') || key.includes('scoreDamageBoost') || key.includes('lifeSteal') || 
           key.includes('pierceSlow') || key.includes('powerGrenadeDrop') || key.includes('catPet') || 
           key.includes('valkyrieCurse') || key.includes('basicBurst') || key.includes('powerSpeedCrit') || 
           key.includes('grenadeChain') || key.includes('valkyrieBlessing') || key.includes('powerSmallBullet') || 
           key.includes('superCritical') || key.includes('pierceEnhanced') || key.includes('dogPet') || 
           key.includes('dotBoost') || key.includes('basicCritical')){
          // íŠ¹ë³„ ë…¸ë‘ ë²„í”„ (ì‹ ê·œ í¬í•¨)
          buffEl.style.borderLeftColor = '#fbbf24';
          buffEl.style.borderLeftWidth = '4px';
          buffEl.style.borderLeftStyle = 'solid';
          buffEl.style.background = 'linear-gradient(135deg, rgba(251,191,36,0.1), rgba(251,191,36,0.05))'; 
          buffEl.style.boxShadow = '0 0 8px rgba(251,191,36,0.3)';
        } else if(key.includes('basicAwakening') || key.includes('powerAwakening') || key.includes('pierceAwakening') || 
                  key.includes('grenadeAwakening') || key.includes('playerAwakening')){
          // í”„ë¦¬ì¦˜ ë²„í”„ (ì‹ ê·œ í¬í•¨)
          buffEl.style.borderLeftColor = '#8b5cf6';
          buffEl.style.borderLeftWidth = '4px';
          buffEl.style.borderLeftStyle = 'solid';
          buffEl.style.background = 'linear-gradient(135deg, rgba(139,92,246,0.1), rgba(139,92,246,0.05))'; 
          buffEl.style.boxShadow = '0 0 12px rgba(139,92,246,0.5)';
        } else if(key.includes('basicEnhancedBullets') || key.includes('powerRapidFire') || key.includes('piercePenetration')){
          // ë§ˆìŠ¤í„° ë²„í”„ (ìµœê³  ë“±ê¸‰)
          buffEl.style.borderLeftColor = '#dc2626';
          buffEl.style.borderLeftWidth = '5px';
          buffEl.style.borderLeftStyle = 'solid';
          buffEl.style.background = 'linear-gradient(135deg, rgba(220,38,38,0.15), rgba(220,38,38,0.08))'; 
          buffEl.style.boxShadow = '0 0 15px rgba(220,38,38,0.6), 0 0 30px rgba(220,38,38,0.3)';
          buffEl.style.borderRadius = '6px';
          buffEl.style.borderTop = '1px solid rgba(220,38,38,0.3)';
          buffEl.style.borderRight = '1px solid rgba(220,38,38,0.3)';
          buffEl.style.borderBottom = '1px solid rgba(220,38,38,0.3)';
        } else if(key.includes('grenadeCooldown') || key.includes('pierceSize') || key.includes('zombieExplode') || 
                  key.includes('speedDodge') || key.includes('doubleHealth') || key.includes('autoPierce') || 
                  key.includes('healingOrbs') || key.includes('flameOrbs') || key.includes('poisonPools') || 
                  key.includes('pierceCount') || key.includes('burnEffect') || key.includes('bossDamage') || 
                  key.includes('grenadeRange')){
          // ê¸°ë³¸ ë²„í”„ (íšŒìƒ‰ í…Œë‘ë¦¬)
          buffEl.style.borderLeftColor = '#6b7280';
          buffEl.style.borderLeftWidth = '3px';
          buffEl.style.borderLeftStyle = 'solid';
          buffEl.style.background = 'rgba(0,0,0,0.7)';
        } else if(key.includes('g_doubleCast10') || key.includes('pierceFaster200') || key.includes('powerFaster150') || 
                  key.includes('powerBurn80') || key.includes('powerExtraBullet20') || key.includes('basicMega005') || 
                  key.includes('buffGrenadePlus100') || key.includes('grenadePlus200And10pctHP') || key.includes('safeguard5s') || 
                  key.includes('swordEvery10s') || key.includes('score15On1pct') || key.includes('powerRadial10s') || 
                  key.includes('grenadePlus50OnDOT') || key.includes('powerKnockback') || key.includes('basicInstakillRare') || 
                  key.includes('basicPlus35') || key.includes('pierceCrit20')){
          // ì‹ ê·œ ì¼ë°˜ ë²„í”„ (ì²­ë¡ìƒ‰ í…Œë‘ë¦¬)
          buffEl.style.borderLeftColor = '#06b6d4';
          buffEl.style.borderLeftWidth = '3px';
          buffEl.style.borderLeftStyle = 'solid';
          buffEl.style.background = 'linear-gradient(135deg, rgba(6,182,212,0.1), rgba(6,182,212,0.05))'; 
          buffEl.style.boxShadow = '0 0 6px rgba(6,182,212,0.3)';
        } else {
          // ê¸°ë³¸ ë²„í”„
          buffEl.style.borderLeftColor = '#6b7280';
          buffEl.style.borderLeftWidth = '3px';
          buffEl.style.borderLeftStyle = 'solid';
          buffEl.style.background = 'rgba(0,0,0,0.7)';
        }
        
        buffList.appendChild(buffEl);
      }
    });
  }

  function updateHealthDisplay(){
    const percentage = (player.health / player.maxHealth) * 100;
    healthFill.style.width = percentage + '%';
    healthEl.textContent = Math.floor(player.health) + ' / ' + player.maxHealth;
    
    // ëª¨ë°”ì¼ UI ì—…ë°ì´íŠ¸
    mobileHealthFill.style.width = percentage + '%';
    mobileHealthText.textContent = Math.floor(player.health) + '/' + player.maxHealth;
  }

  function autoPierceShoot(){
    if(!buffs.autoPierce) return;
    for(let i = 0; i < 8; i++){
      const angle = (i * Math.PI * 2) / 8;
      const bulletR = buffs.pierceSize ? 24 : 16;
      spawnBullet(player.x, player.y, Math.cos(angle) * 400, Math.sin(angle) * 400, bulletR, 2000, '#ff4444', 50, true, { weaponId: 'pierce' });
    }
  }

  function powerRadialShoot(){
    if(!buffs.powerRadial10s) return;
    const w = weapons[1];
    for(let i=0;i<8;i++){
      const angle = (i * Math.PI * 2) / 8;
      spawnBullet(player.x, player.y, Math.cos(angle) * w.bulletSpeed, Math.sin(angle) * w.bulletSpeed, w.bulletR, 1200, w.color, w.damage, false, { weaponId: 'power' });
    }
  }

  function fireSword(){
    if(!buffs.swordEvery10s) return;
    // ê°€ì‹œì„±â†‘(ì§„í•œ ë°˜íˆ¬ëª…), ì†ë„ ì•½ê°„ ê°ì†Œ, ë²”ìœ„ ì•½ê°„ ì¦ê°€
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    const speed = 540;      // 700 -> 540
    const life = 320;       // 220 -> 320
    const dmg = 400;
    spawnBullet(
      player.x + Math.cos(ang)*(player.r+12),
      player.y + Math.sin(ang)*(player.r+12),
      Math.cos(ang)*speed,
      Math.sin(ang)*speed,
      22,                   // 18 -> 22
      life,
      'rgba(250,252,255,0.9)',
      dmg,
      false,
      { weaponId: 'sword', alpha: 0.9 }
    );
  }

  function updateFlameOrbs(dt){
    if(!buffs.flameOrbs) return;
    flameOrbAngle += dt * 2;
    flameOrbs.forEach(orb => {
      orb.angle += dt * 2;
      const x = player.x + Math.cos(orb.angle) * orb.distance;
      const y = player.y + Math.sin(orb.angle) * orb.distance;
      [...zombies, ...bosses].forEach(enemy => {
        if(enemy && Math.hypot(x - enemy.x, y - enemy.y) < orb.r + enemy.r){
          if(enemy.hp){
            enemy.hp -= 100;
            if(enemy.hp <= 0){
              if(zombies.includes(enemy)){
                let add = Math.ceil(10 + enemy.r + enemy.speed/4);
                if(buffs.score15On1pct && Math.random() < 0.01) add = Math.ceil(add * 1.5);
                score += add;
                zombies.splice(zombies.indexOf(enemy), 1);
              } else if(bosses.includes(enemy)){
                const wasMutant = enemy.isMutant;
                bosses.splice(bosses.indexOf(enemy), 1);
                score += 500;
                spawnCard(enemy.x, enemy.y, wasMutant ? 2 : 1);
              }
            }
          }
        }
      });
    });
  }

  function updatePoisonPools(dt){
    if(!buffs.poisonPools) return;
    poisonTimer += dt * 1000;
    if(poisonTimer >= 15000){
      poisonTimer = 0;
      poisonPools.push({ x: player.x + rand(-100, 100), y: player.y + rand(-100, 100), r: 180, life: 5000, born: performance.now() }); // ë²”ìœ„ 3ë°°
    }
    for(let i = poisonPools.length - 1; i >= 0; i--){
      const pool = poisonPools[i];
      if(performance.now() - pool.born > pool.life){ poisonPools.splice(i, 1); continue; }
      zombies.forEach(z => {
        if(Math.hypot(z.x - pool.x, z.y - pool.y) < pool.r + z.r){
          // ì²´ë ¥ì˜ 1%/s -> z.hp ë‹¨ìœ„ ì ìš©
          let poisonDamage = (0.01 * z.hp) * dt;
          if(buffs.dotBoost) poisonDamage += 10 * dt; // DOT ì¶”ê°€ ë°ë¯¸ì§€ +100 (ì´ˆë‹¹ 10)
          z.hp -= poisonDamage;
          z.poisonedTime = Math.min(2000, (z.poisonedTime || 0) + 1000 * dt);
        }
      });
      bosses.forEach(b => {
        if(Math.hypot(b.x - pool.x, b.y - pool.y) < pool.r + b.r){
          let poisonDamage = (0.01 * b.hp) * dt;
          if(buffs.dotBoost) poisonDamage += 10 * dt; // DOT ì¶”ê°€ ë°ë¯¸ì§€ +100 (ì´ˆë‹¹ 10)
          b.hp -= poisonDamage;
        }
      });
    }
  }

  function applySafeguard(dt){
    const now = performance.now();
    if(safeguardActive){
      if(now > safeguardUntil){
        safeguardActive = false;
      }
    }
  }

  // íŠ¹ë³„ ë²„í”„ ê¸°ëŠ¥ë“¤
  function updateGravityField(dt){
    if(!buffs.gravityField) return;
    
    // ì¤‘ë ¥ì¥ ë°ë¯¸ì§€ (ì´ˆë‹¹ 60)
    const gravityRadius = 120;
    [...zombies, ...bosses].forEach(enemy => {
      if(enemy && Math.hypot(enemy.x - player.x, enemy.y - player.y) < gravityRadius + enemy.r){
        enemy.hp -= 60 * dt; // ì´ˆë‹¹ 60 ë°ë¯¸ì§€
      }
    });
  }

  function getScoreDamageMultiplier(){
    if(!buffs.scoreDamageBoost) return 1;
    return 1 + (Math.floor(score / 2000) * 0.005); // 2000ì ë‹¹ 0.5% ì¦ê°€
  }

  function getGameTime(){
    return (performance.now() - gameStartTime) / 1000; // ì´ˆ ë‹¨ìœ„
  }

  function getBasicDamageBonus(){
    const minutes = Math.floor(getGameTime() / 180); // 3ë¶„ë§ˆë‹¤
    return minutes * 10; // 3ë¶„ë§ˆë‹¤ 10 ì¦ê°€
  }

  function getLateGameMultiplier(){
    const gameTime = getGameTime();
    if(gameTime >= 2700) return 1.75; // 45ë¶„ í›„ 75% ì¦ê°€
    if(gameTime >= 1800) return 1.5;  // 30ë¶„ í›„ 50% ì¦ê°€
    if(gameTime >= 900) return 1.25;  // 15ë¶„ í›„ 25% ì¦ê°€
    return 1; // ê¸°ë³¸
  }

  function getLateGameSpawnMultiplier(){
    const gameTime = getGameTime();
    if(gameTime >= 2700) return 3;  // 45ë¶„ í›„ 200% ì¦ê°€
    if(gameTime >= 1800) return 2.5; // 30ë¶„ í›„ 150% ì¦ê°€
    if(gameTime >= 900) return 2;   // 15ë¶„ í›„ 100% ì¦ê°€
    return 1; // ê¸°ë³¸
  }

  function updateHighScores(score){
    highScores.push(Math.floor(score));
    highScores.sort((a, b) => b - a);
    highScores = highScores.slice(0, 8); // ìµœëŒ€ 8ê°œë§Œ ìœ ì§€
    localStorage.setItem('zombieShooter_highScores', JSON.stringify(highScores));
    updateHighScoresDisplay();
  }

  function updateHighScoresDisplay(){
    highScoresEl.innerHTML = '';
    highScores.forEach((score, index) => {
      const scoreEl = document.createElement('div');
      scoreEl.textContent = `${index + 1}. ${score.toLocaleString()}`;
      scoreEl.style.color = index === 0 ? '#fbbf24' : '#cbd5e1';
      highScoresEl.appendChild(scoreEl);
    });
  }

  function updateCatPet(dt){
    if(!buffs.catPet) return;
    catPetTimer += dt * 1000;
    if(catPetTimer >= 4000){ // 4ì´ˆë§ˆë‹¤
      catPetTimer = 0;
      
      // ì¢€ë¹„ê°€ ê°€ì¥ ë§ì´ ëª¨ì¸ êµ¬ì—­ ì°¾ê¸°
      let maxZombies = 0;
      let targetX = player.x;
      let targetY = player.y;
      
      for(let i = 0; i < 8; i++){
        const angle = (i * Math.PI * 2) / 8;
        const checkX = player.x + Math.cos(angle) * 150;
        const checkY = player.y + Math.sin(angle) * 150;
        
        let zombieCount = 0;
        zombies.forEach(z => {
          if(Math.hypot(z.x - checkX, z.y - checkY) < 80){
            zombieCount++;
          }
        });
        
        if(zombieCount > maxZombies){
          maxZombies = zombieCount;
          targetX = checkX;
          targetY = checkY;
        }
      }
      
      // ê³ ì–‘ì´ í« ì „ìš© ìˆ˜ë¥˜íƒ„ ìƒì„± (ì¿¨íƒ€ì„ ë¬´ì‹œ)
      const sx = player.x + 30, sy = player.y - 20; // ê³ ì–‘ì´ ìœ„ì¹˜
      const dx = targetX - sx, dy = targetY - sy;
      const dist = Math.hypot(dx,dy);
      const gravity = 1400;
      const travelTime = Math.min(1.1, Math.max(0.45, dist / 900));
      let vx = dx / travelTime;
      let vy = (dy - 0.5 * gravity * travelTime * travelTime) / travelTime;
      if(!isFinite(vx) || !isFinite(vy)){ vx = Math.sign(dx)*200; vy = -300; }
      const baseRange = 110;
      const range = buffs.grenadeRange ? Math.round(baseRange * 1.5) : baseRange;
      const baseDamage = 500; // ê³ ì–‘ì´ í« ì „ìš© ë°ë¯¸ì§€
      spawnGrenade({ x: sx, y: sy, vx, vy, born: performance.now(), fuse: Math.ceil(travelTime*1000 + 200), explodeRadius: range, damage: baseDamage, targetX, targetY, fromBuff: true, isCatPet: true });
    }
  }
  
  function updateDogPet(dt){
    if(!buffs.dogPet) return;
    dogPetTimer += dt * 1000;
    
    // ê³ ì–‘ì´ í«ì´ ìˆìœ¼ë©´ 4ì´ˆë§ˆë‹¤, ì—†ìœ¼ë©´ 7ì´ˆë§ˆë‹¤
    const interval = buffs.catPet ? 4000 : 7000;
    
    if(dogPetTimer >= interval){
      dogPetTimer = 0;
      
      // ì¢€ë¹„ê°€ ê°€ì¥ ë§ì´ ëª¨ì¸ êµ¬ì—­ ì°¾ê¸°
      let maxZombies = 0;
      let targetX = player.x;
      let targetY = player.y;
      
      for(let i = 0; i < 8; i++){
        const angle = (i * Math.PI * 2) / 8;
        const checkX = player.x + Math.cos(angle) * 150;
        const checkY = player.y + Math.sin(angle) * 150;
        
        let zombieCount = 0;
        zombies.forEach(z => {
          if(Math.hypot(z.x - checkX, z.y - checkY) < 80){
            zombieCount++;
          }
        });
        
        if(zombieCount > maxZombies){
          maxZombies = zombieCount;
          targetX = checkX;
          targetY = checkY;
        }
      }
      
      // ëœë¤ íƒ„í™˜ ì„ íƒ (ê¸°ë³¸ì´ 5ê°œ, ê´€í†µëŒ€í¬ 1ê°œ, ê°•ë ¥ì´ 1ê°œ)
      const randomWeapon = Math.random();
      const dogX = player.x - 30, dogY = player.y - 20; // ê°•ì•„ì§€ ìœ„ì¹˜
      const ang = Math.atan2(targetY - dogY, targetX - dogX);
      
      if(randomWeapon < 5/7){ // ê¸°ë³¸ì´ íƒ„í™˜ 5ê°œ
        for(let i = 0; i < 5; i++){
          const spreadAngle = ang + (Math.random() - 0.5) * 0.4;
          spawnBullet(dogX, dogY, Math.cos(spreadAngle) * weapons[0].bulletSpeed, Math.sin(spreadAngle) * weapons[0].bulletSpeed,
            weapons[0].bulletR, 2000, weapons[0].color, weapons[0].damage, false, { weaponId: 'basic', isDogPet: true });
        }
      } else if(randomWeapon < 6/7){ // ê´€í†µëŒ€í¬ íƒ„í™˜ 1ê°œ
        spawnBullet(dogX, dogY, Math.cos(ang) * weapons[2].bulletSpeed, Math.sin(ang) * weapons[2].bulletSpeed,
          weapons[2].bulletR, 2000, weapons[2].color, weapons[2].damage, true, { weaponId: 'pierce', isDogPet: true });
      } else { // ê°•ë ¥ì´ íƒ„í™˜ 1ê°œ
        spawnBullet(dogX, dogY, Math.cos(ang) * weapons[1].bulletSpeed, Math.sin(ang) * weapons[1].bulletSpeed,
          weapons[1].bulletR, 2000, weapons[1].color, weapons[1].damage, false, { weaponId: 'power', isDogPet: true });
      }
    }
  }

  function updateChainExplosions(dt){
    for(let i = chainExplosions.length - 1; i >= 0; i--){
      const explosion = chainExplosions[i];
      explosion.timer -= dt * 1000;
      
      if(explosion.timer <= 0){
        // ì—°ì‡„ í­ë°œ ìˆ˜ë¥˜íƒ„ ìƒì„± (ì¿¨íƒ€ì„ ë¬´ì‹œ)
        const baseRange = 60;
        const range = buffs.grenadeRange ? Math.round(baseRange * 1.5) : baseRange;
        const baseDamage = 100;
        spawnGrenade({ x: explosion.x, y: explosion.y, vx: 0, vy: 0, born: performance.now(), fuse: 100, explodeRadius: range, damage: baseDamage, fromBuff: true, isChainExplosion: true });
        chainExplosions.splice(i, 1);
      }
    }
  }
  
  function updateFlameExplosions(dt){
    for(let i = flameExplosions.length - 1; i >= 0; i--){
      const explosion = flameExplosions[i];
      explosion.timer -= dt * 1000;
      
      if(explosion.timer <= 0){
        // í™”ì—¼ í­ë°œ ì²˜ë¦¬ (ë²”ìœ„ ë‚´ ì ë“¤ì—ê²Œ 1000 ë°ë¯¸ì§€)
        const explosionRadius = 120;
        
        // ì¢€ë¹„ ë°ë¯¸ì§€
        for(let j = zombies.length-1; j >= 0; --j){
          const z = zombies[j];
          if(!z) continue;
          const d = Math.hypot(z.x - explosion.x, z.y - explosion.y);
          if(d <= explosionRadius + z.r){
            z.hp -= 1000;
            if(z.hp <= 0){
              let add = Math.ceil(10 + z.r + z.speed/4);
              if(buffs.score15On1pct && Math.random() < 0.01) add = Math.ceil(add * 1.5);
              score += add;
              zombies.splice(j, 1);
            }
          }
        }
        
        // ë³´ìŠ¤ ë°ë¯¸ì§€
        for(let j = bosses.length-1; j >= 0; --j){
          const boss = bosses[j];
          if(!boss) continue;
          const d = Math.hypot(boss.x - explosion.x, boss.y - explosion.y);
          if(d <= explosionRadius + boss.r){
            boss.hp -= 1000;
            if(boss.hp <= 0){
              score += 500;
              const wasMutant = boss.isMutant;
              spawnCard(boss.x, boss.y, wasMutant ? 2 : 1);
              bosses.splice(j, 1);
              cameraShake = 18;
            }
          }
        }
        
        // í™”ì—¼ ì¥íŒ ìƒì„± (10ì´ˆê°„ ì§€ì†)
        flamePools.push({ x: explosion.x, y: explosion.y, r: explosionRadius, life: 10000, born: performance.now() });
        
        flameExplosions.splice(i, 1);
      }
    }
  }
  
  function updateFlamePools(dt){
    for(let i = flamePools.length - 1; i >= 0; i--){
      const pool = flamePools[i];
      if(performance.now() - pool.born > pool.life){
        flamePools.splice(i, 1);
        continue;
      }
      
      // í™”ì—¼ ì¥íŒ ë°ë¯¸ì§€ (ì´ˆë‹¹ ì  ì²´ë ¥ 1%)
      zombies.forEach(z => {
        if(Math.hypot(z.x - pool.x, z.y - pool.y) < pool.r + z.r){
          let flameDamage = (0.01 * z.hp) * dt;
          if(buffs.dotBoost) flameDamage += 10 * dt; // DOT ì¶”ê°€ ë°ë¯¸ì§€ +100 (ì´ˆë‹¹ 10)
          z.hp -= flameDamage;
        }
      });
      bosses.forEach(b => {
        if(Math.hypot(b.x - pool.x, b.y - pool.y) < pool.r + b.r){
          let flameDamage = (0.01 * b.hp) * dt;
          if(buffs.dotBoost) flameDamage += 10 * dt; // DOT ì¶”ê°€ ë°ë¯¸ì§€ +100 (ì´ˆë‹¹ 10)
          b.hp -= flameDamage;
        }
      });
    }
  }

  function updateSlowedEnemies(dt){
    for(let i = slowedEnemies.length - 1; i >= 0; i--){
      const enemy = slowedEnemies[i];
      enemy.timer -= dt * 1000;
      
      if(enemy.timer <= 0){
        enemy.enemy.speed = enemy.originalSpeed;
        slowedEnemies.splice(i, 1);
      }
    }
  }

  function update(dt){
    if(!running) return;
    const now = performance.now();
    let mvx=0, mvy=0;
    if(keys['arrowleft']||keys['a']) mvx -= 1;
    if(keys['arrowright']||keys['d']) mvx += 1;
    if(keys['arrowup']||keys['w']) mvy -= 1;
    if(keys['arrowdown']||keys['s']) mvy += 1;
    
    // ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± ì…ë ¥ ì²˜ë¦¬
    if(joystickActive){
      mvx = joystickOffset.x;
      mvy = joystickOffset.y;
    }
    
    if(mvx||mvy){ const L=Math.hypot(mvx,mvy); mvx/=L; mvy/=L; }

    const safeguardSpeed = (safeguardActive ? 2 : 1);
    const valkyrieSpeed = (valkyrieBlessingActive && buffs.valkyrieBlessing ? 1.15 : 1); // ë°œí‚¤ë¦¬ì˜ ì¶•ë³µ: ì´ì† 15% ì¦ê°€
    
    // ê°•ë ¥ì´ ì—°ì‚¬: ë¬´ê¸° ì „í™˜ì‹œ ì´ì† +50% (1ì´ˆê°„, ì¿¨íƒ€ì„ 10ì´ˆ)
    let powerSwitchSpeed = 1;
    if(buffs.powerRapidFire){
      powerWeaponSwitchTimer += dt * 1000;
      powerWeaponSwitchCooldown = Math.max(0, powerWeaponSwitchCooldown - dt * 1000);
      
      if(powerWeaponSwitchTimer > 0){
        if(powerWeaponSwitchTimer <= 1000){
          powerSwitchSpeed = 1.5; // 1ì´ˆê°„ 50% ë¹¨ë¼ì§
        } else if(powerWeaponSwitchTimer <= 2000){
          // 1ì´ˆê°„ ì„œì„œíˆ ëŠë ¤ì§
          const fadeProgress = (powerWeaponSwitchTimer - 1000) / 1000;
          powerSwitchSpeed = 1.5 - (0.5 * fadeProgress);
        } else {
          powerWeaponSwitchTimer = 0;
          powerSwitchSpeed = 1;
        }
      }
    }
    
    const speedMultiplier = (buffs.speedDodge ? 1.5 : 1) * safeguardSpeed * valkyrieSpeed * powerSwitchSpeed;
    const oldX = player.x, oldY = player.y;
    player.x += mvx * player.speed * speedMultiplier * dt;
    player.y += mvy * player.speed * speedMultiplier * dt;
    player.x = Math.max(20, Math.min(W-20, player.x));
    player.y = Math.max(20, Math.min(H-20, player.y));
    
    // í”Œë ˆì´ì–´ ê°ì„±: ì´ë™ ê±°ë¦¬ ì¶”ì 
    if(buffs.playerAwakening){
      const moved = Math.hypot(player.x - oldX, player.y - oldY);
      playerDistance += moved;
      
      // 100 ê±°ë¦¬ë§ˆë‹¤ ì²´ë ¥ 1 íšŒë³µ
      if(playerDistance >= 100){
        playerDistance -= 100;
        player.health = Math.min(player.maxHealth, player.health + 1);
      }
    }

    // ë°œì‚¬
    const isShooting = mouse.down || keys[' '] || attackJoystickActive;
    if(isShooting && now - player.lastShot > (player.fireRate||1000)){
      let ang;
      if(attackJoystickActive && attackJoystickOffset.x !== 0 && attackJoystickOffset.y !== 0){
        // ëª¨ë°”ì¼ ê³µê²© ì¡°ì´ìŠ¤í‹±ìœ¼ë¡œ ì¡°ì¤€
        ang = Math.atan2(attackJoystickOffset.y, attackJoystickOffset.x);
      } else {
        // ë§ˆìš°ìŠ¤ ì¡°ì¤€
        ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
      }
      const w = weapons[currentWeapon] || weapons[0];

      // ê¸°ë³¸ì´: íŠ¹ìˆ˜íƒ„ í™•ë¥  ì²˜ë¦¬
      if(currentWeapon === 0){
        // ê¸°ë³¸ì´ ë²„ìŠ¤íŠ¸ (30ë°œë§ˆë‹¤ 10ë°œ ì¶”ê°€)
        if(buffs.basicBurst){
          basicShotCount++;
          if(basicShotCount >= 30){
            basicShotCount = 0;
            // 10ë°œ ì¶”ê°€ ë°œì‚¬
            for(let i = 0; i < 10; i++){
              const spreadAngle = ang + (Math.random() - 0.5) * 0.3;
              spawnBullet(player.x + Math.cos(spreadAngle)*(player.r+8), player.y + Math.sin(spreadAngle)*(player.r+8),
                Math.cos(spreadAngle)*w.bulletSpeed, Math.sin(spreadAngle)*w.bulletSpeed,
                w.bulletR, 2000, '#ff6b35', 250, false, { weaponId: 'basic' });
            }
          }
        }
        
        // ê¸°ë³¸ì´ ê°ì„±: 35ë°œë§ˆë‹¤ ëœë¤ íƒ„í™˜
        if(buffs.basicAwakening){
          basicShotCount++;
          if(basicShotCount >= 35){
            basicShotCount = 0;
            const randomWeapon = Math.random();
            if(randomWeapon < 0.5){
              // ê´€í†µ ëŒ€í¬ íƒ„í™˜
              spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
                Math.cos(ang)*weapons[2].bulletSpeed, Math.sin(ang)*weapons[2].bulletSpeed,
                weapons[2].bulletR, 2000, weapons[2].color, weapons[2].damage, true, { weaponId: 'pierce' });
            } else {
              // ê°•ë ¥ì´ íƒ„í™˜
              spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
                Math.cos(ang)*weapons[1].bulletSpeed, Math.sin(ang)*weapons[1].bulletSpeed,
                weapons[1].bulletR, 2000, weapons[1].color, weapons[1].damage, false, { weaponId: 'power' });
            }
          }
        }
        
        // ì‹ ì˜ íƒ„í™˜ (0.06%)
        if(buffs.basicInstakillRare && Math.random() < 0.0006){
          spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
            Math.cos(ang)*w.bulletSpeed, Math.sin(ang)*w.bulletSpeed,
            w.bulletR+2, 2000, '#3b82f6', 9999999, false,
            { weaponId: 'basic', instantKill: true, outline: '#ef4444' });
        }else if(buffs.basicMega005 && Math.random() < 0.01){ // 1%ë¡œ ì¦ê°€
          // ê·¹ëŒ€ íƒ„: 40ë°°, ê´€í†µ 5
          spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
            Math.cos(ang)*w.bulletSpeed, Math.sin(ang)*w.bulletSpeed,
            w.bulletR*5, 2000, '#facc15', w.damage*40, true,
            { weaponId: 'basic', isMega: true, outline: '#22c55e', maxPierceHits: 5 });
        }else{
          // ê¸°ë³¸ì´ ì‹œê°„ ë°ë¯¸ì§€ ë³´ë„ˆìŠ¤ ì ìš©
          const timeBonus = getBasicDamageBonus();
          let totalDamage = w.damage + timeBonus;
          
          // ê¸°ë³¸ì´ ê°•í™” íƒ„í™˜: ë°ë¯¸ì§€ +100
          if(buffs.basicEnhancedBullets){
            totalDamage += 100;
            spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
              Math.cos(ang)*w.bulletSpeed, Math.sin(ang)*w.bulletSpeed,
              w.bulletR, 2000, '#ff0000', totalDamage, false, 
              { weaponId: 'basic', isEnhanced: true, outline: '#000000' });
          } else {
            spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
              Math.cos(ang)*w.bulletSpeed, Math.sin(ang)*w.bulletSpeed,
              w.bulletR, 2000, w.color, totalDamage, false, { weaponId: 'basic' });
          }
        }
      } else if(currentWeapon === 1){
        // ê°•ë ¥ì´: 20% ì¶”ê°€íƒ„, DOT(ë²„í”„4), ì†ë„+ì¹˜ëª…íƒ€
        const bulletSpeed = buffs.powerSpeedCrit ? w.bulletSpeed + 100 : w.bulletSpeed;
        spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
          Math.cos(ang)*bulletSpeed, Math.sin(ang)*bulletSpeed,
          w.bulletR, 2000, w.color, w.damage, false, { weaponId: 'power' });
        
        // ë°œí‚¤ë¦¬ì˜ ì¶•ë³µ: ê°•ë ¥ì´ ì—°ì† ë°œì‚¬ ì¹´ìš´íŠ¸
        if(buffs.valkyrieBlessing){
          powerShotCount++;
          if(powerShotCount >= 10 && !valkyrieBlessingActive){
            valkyrieBlessingActive = true;
            spawnFloatingText('ë°œí‚¤ë¦¬ì˜ ì¶•ë³µ!', player.x, player.y-30, '#fbbf24');
            applyWeaponBuffs();
            updateWeaponStats();
          }
        }
        
        // ê°•ë ¥ì´ ì‘ì€ ì¶”ê°€ íƒ„í™˜ (50% í¬ê¸°, 50% ë°ë¯¸ì§€)
        if(buffs.powerSmallBullet){
          spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
            Math.cos(ang)*bulletSpeed, Math.sin(ang)*bulletSpeed,
            w.bulletR * 0.5, 2000, w.color, w.damage * 0.5, false, { weaponId: 'power' });
        }
        
        if(buffs.powerExtraBullet20 && Math.random()<0.5){ // 50%ë¡œ ì¦ê°€
          spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
            Math.cos(ang)*bulletSpeed, Math.sin(ang)*bulletSpeed,
            w.bulletR, 2000, w.color, w.damage, false, { weaponId: 'power' });
        }
      } else {
        // ê´€í†µëŒ€í¬
        const bulletR = buffs.pierceSize ? 24 : w.bulletR;
        
        // ê´€í†µëŒ€í¬ ê°•í™” íƒ„í™˜ (3% í™•ë¥ )
        if(buffs.pierceEnhanced && Math.random() < 0.03){
          const enhancedDamage = w.damage * 1.3; // 30% ë” í° ë°ë¯¸ì§€
          const enhancedSpeed = w.bulletSpeed * 0.7; // 30% ë” ëŠë¦¼
          const enhancedSize = bulletR * 1.3; // 30% ë” í° í¬ê¸°
          spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
            Math.cos(ang)*enhancedSpeed, Math.sin(ang)*enhancedSpeed,
            enhancedSize, 2000, '#ff4500', enhancedDamage, false, // ê´€í†µí•˜ì§€ ì•ŠìŒ
            { weaponId: 'pierce', isEnhanced: true, outline: '#ff0000' });
        } else {
          spawnBullet(player.x + Math.cos(ang)*(player.r+8), player.y + Math.sin(ang)*(player.r+8),
            Math.cos(ang)*w.bulletSpeed, Math.sin(ang)*w.bulletSpeed,
            bulletR, 2000, w.color, w.damage, true, { weaponId: 'pierce' });
        }
      }
      player.lastShot = now;
    }

    // ìë™ ê´€í†µ
    autoShootTimer += dt * 1000;
    if(autoShootTimer >= 10000){
      autoShootTimer = 0;
      autoPierceShoot();
    }

    // 10ì´ˆë§ˆë‹¤ ê°•ë ¥ì´ ë°©ì‚¬(ë²„í”„12)
    powerBurstTimer += dt * 1000;
    if(powerBurstTimer >= 10000){
      powerBurstTimer = 0;
      powerRadialShoot();
    }

    // 10ì´ˆë§ˆë‹¤ ì „ë°© ê²€(ë²„í”„10)
    swordTimer += dt * 1000;
    if(swordTimer >= 10000){
      swordTimer = 0;
      fireSword();
    }

    updateFlameOrbs(dt);
    updatePoisonPools(dt);
    applySafeguard(dt);
    
    // íŠ¹ë³„ ë²„í”„ ì—…ë°ì´íŠ¸
    updateGravityField(dt);
    updateCatPet(dt);
    updateDogPet(dt);
    updateChainExplosions(dt);
    updateSlowedEnemies(dt);
    updateFlameExplosions(dt);
    updateFlamePools(dt);

    // ì´ì•Œ ì´ë™
    cleanupBullets();
    for(let i = bullets.length-1; i>=0; --i){
      const b = bullets[i]; if(!b){ bullets.splice(i,1); continue; }
      b.x += b.dx * dt; b.y += b.dy * dt;
    }

    // ìˆ˜ë¥˜íƒ„ ë¬¼ë¦¬
    for(let gi = grenades.length-1; gi>=0; --gi){
      const g = grenades[gi];
      const gravity = 1400;
      g.vy += gravity * dt; g.x += g.vx * dt; g.y += g.vy * dt;
      if(g.targetX !== undefined){
        const td = Math.hypot(g.x - g.targetX, g.y - g.targetY);
        if(td < 22){ explodeGrenade(g); grenades.splice(gi,1); processQueuedGrenades(); continue; }
      }
      if(now - g.born > g.fuse){ explodeGrenade(g); grenades.splice(gi,1); processQueuedGrenades(); continue; }
      if(g.y > H-10){ explodeGrenade(g); grenades.splice(gi,1); processQueuedGrenades(); continue; }
    }

    // ê²Œì„ ì‹œê°„ ì²´í¬ (ë‹¨ê³„ì  ë‚œì´ë„ ì¦ê°€ëŠ” getLateGameMultiplierì—ì„œ ì²˜ë¦¬)
    
    // ìŠ¤í° ë° ë‚œì´ë„: ì¦ê°€ìœ¨ 1.5ë°° ê°€ì† -> 0.92 â†’ 0.88
    spawnTimer += dt*1000; difficultyTimer += dt*1000; bossTimer += dt*1000; mutantTimer += dt*1000;
    if(spawnTimer > spawnInterval * getLateGameSpawnMultiplier()){ spawnTimer = 0; spawnZombie(); }
    if(difficultyTimer > 8000){ difficultyTimer = 0; spawnInterval = Math.max(300, spawnInterval * 0.88); }
    // ë§¤ 5ë¶„ ëŒì—°ë³€ì´ ë³´ìŠ¤, í•´ë‹¹ ë¶„ì˜ ì¼ë°˜ ë³´ìŠ¤ëŠ” ëŒ€ì²´
    if(mutantTimer > 300000){ mutantTimer = 0; bossTimer = 0; spawnMutantBoss(); }
    else if(bossTimer > 60000){ bossTimer = 0; spawnBoss(); }

    // ì¢€ë¹„ ì´ë™ ë° DOT
    for(let i=0;i<zombies.length;i++){
      const z = zombies[i]; if(!z) continue;
      const ang = Math.atan2(player.y - z.y, player.x - z.x);
      
      // ì¤‘ë ¥ì¥ íš¨ê³¼ ì ìš©
      let currentSpeed = z.speed;
      if(buffs.gravityField && Math.hypot(z.x - player.x, z.y - player.y) < 120 + z.r){
        currentSpeed *= 0.75; // 25% ê°ì†Œ
      }
      
      z.x += Math.cos(ang) * currentSpeed * dt; z.y += Math.sin(ang) * currentSpeed * dt;

      // ìˆ˜ë¥˜íƒ„ í™”ìƒ: DPS = 50 + 5% ì²´ë ¥/ì´ˆ -> z.hp ë‹¨ìœ„ í™˜ì‚°
      if(z.burnTime > 0){
        z.burnTime -= dt * 1000;
        let perSec = (50/10) + 0.05 * z.hp; // 5 + 5% of current hp
        if(buffs.dotBoost) perSec += 10; // DOT ì¶”ê°€ ë°ë¯¸ì§€ +100 (ì´ˆë‹¹ 10)
        z.hp -= perSec * dt;
      }
      // ê°•ë ¥ì´ í™”ìƒ: ì´ˆë‹¹ 80 -> z.hp ë‹¨ìœ„ë¡œ 8
      if(z.powerBurnTime > 0){
        z.powerBurnTime -= dt * 1000;
        let burnDamage = 8;
        if(buffs.dotBoost) burnDamage += 10; // DOT ì¶”ê°€ ë°ë¯¸ì§€ +100 (ì´ˆë‹¹ 10)
        z.hp -= burnDamage * dt;
      }
      if(z.poisonedTime > 0){
        z.poisonedTime -= dt * 1000;
      }

      if(z.hp <= 0){
        let add = Math.ceil(10 + z.r + z.speed/4);
        if(buffs.score15On1pct && Math.random() < 0.01) add = Math.ceil(add * 1.5);
        score += add;
        zombies.splice(i,1);
        i--;
      }
    }

    // ì´ì•Œ-ì¢€ë¹„ ì¶©ëŒ
    for(let i = zombies.length-1; i>=0; --i){
      const z = zombies[i]; if(!z) continue;
      for(let j = bullets.length-1; j>=0; --j){
        const b = bullets[j]; if(!b){ bullets.splice(j,1); continue; }
        const d = Math.hypot(z.x - b.x, z.y - b.y);
        if(d < z.r + b.r){
          if(b.instantKill){
            spawnFloatingText('ì¦‰ì‚¬!!', z.x, z.y-10, '#60a5fa');
            let add = Math.ceil(10 + z.r + z.speed/4);
            if(buffs.score15On1pct && Math.random() < 0.01) add = Math.ceil(add * 1.5);
            score += add;
            zombies.splice(i,1);
            bullets.splice(j,1);
            break;
          }
          // í”¼í•´ ê³„ì‚°
          let raw = b.damage||0;
          let crit = false;
          let superCrit = false;
          
          // ê¸°ë³¸ì´ ì¹˜ëª…íƒ€ (2.5% í™•ë¥ , 1.7ë°°)
          if(b.weaponId === 'basic' && buffs.basicCritical && Math.random() < 0.025){
            raw *= 1.7;
            crit = true;
          }
          
          // ê¸°ë³¸ì´ ê°•í™” íƒ„í™˜: ì—°ì† íƒ€ê²©ì‹œ ë°ë¯¸ì§€ ì¦ê°€
          if(b.isEnhanced && b.weaponId === 'basic'){
            const enemyKey = `${z.x}_${z.y}_${z.r}`; // ì  ê³ ìœ  í‚¤
            const hitCount = enhancedBulletHits.get(enemyKey) || 0;
            enhancedBulletHits.set(enemyKey, hitCount + 1);
            
            // ì—°ì† íƒ€ê²©ì‹œ ë°ë¯¸ì§€ ì¦ê°€ (ìµœëŒ€ 100%, ë³´ìŠ¤ëŠ” 50%)
            const maxMultiplier = bosses.includes(z) ? 0.5 : 1.0;
            const damageMultiplier = Math.min(maxMultiplier, hitCount * 0.01); // 1%ì”© ì¦ê°€
            raw *= (1 + damageMultiplier);
          }
          
          if(b.weaponId === 'pierce' && buffs.pierceCrit20 && Math.random() < 0.2){
            raw *= 1.5;
            crit = true;
          }
          if(b.weaponId === 'power' && (buffs.powerSpeedCrit || buffs.powerAwakening) && Math.random() < 0.2){
            raw *= (buffs.powerAwakening ? 1.8 : 1.5); // ê°ì„± ì‹œ 1.8ë°°, ì¼ë°˜ ì‹œ 1.5ë°°
            crit = true;
          }
          
          // ê°•ë ¥ ì¹˜ëª…íƒ€ ì‹œìŠ¤í…œ (ì¹˜ëª…íƒ€ ë°œë™ ì‹œ 50% í™•ë¥ ë¡œ 2.5ë°°)
          if(crit && buffs.superCritical && Math.random() < 0.5){
            raw *= 2.5;
            superCrit = true;
          }
          
          // ê°•ë ¥ì´ ê°ì„±: í•„ìˆ˜ ì¹˜ëª…íƒ€ + ì²´ë ¥ 2% ì¶”ê°€ í”¼í•´
          if(b.weaponId === 'power' && buffs.powerAwakening){
            raw *= 1.8;
            raw += z.hp * 0.02; // ì²´ë ¥ì˜ 2% ì¶”ê°€ í”¼í•´
            crit = true;
          }
          
          // ìŠ¤ì½”ì–´ ë°ë¯¸ì§€ ë¶€ìŠ¤íŠ¸ ì ìš©
          raw *= getScoreDamageMultiplier();
          
          // í”Œë ˆì´ì–´ ê°ì„±: ì…íˆëŠ” í”¼í•´ 20% ì¦ê°€
          if(buffs.playerAwakening){
            raw *= 1.2;
          }
          
          // ê´€í†µëŒ€í¬ ê´€í†µë ¥: ì  ì²´ë ¥ 1% ì¶”ê°€ í”¼í•´
          if(b.weaponId === 'pierce' && buffs.piercePenetration){
            raw += z.hp * 0.01;
          }
          
          // ë°œí‚¤ë¦¬ì˜ ì €ì£¼ ì ìš©
          if(buffs.valkyrieCurse && b.weaponId === 'power'){
            if(!cursedEnemies.find(ce => ce.enemy === z)){
              cursedEnemies.push({ enemy: z, multiplier: 1.1 });
            } else {
              const curse = cursedEnemies.find(ce => ce.enemy === z);
              curse.multiplier += 0.1;
            }
          }
          
          let damage = Math.ceil(raw/10);
          
          // ì €ì£¼ëœ ì ì—ê²Œ ì¶”ê°€ í”¼í•´
          const curse = cursedEnemies.find(ce => ce.enemy === z);
          if(curse){
            damage = Math.ceil(damage * curse.multiplier);
          }
          
          // ë¬´ê¸°ë³„ ë°ë¯¸ì§€ ì¶”ì 
          if(b.weaponId === 'basic') weaponDamage.basic += damage;
          else if(b.weaponId === 'power') weaponDamage.power += damage;
          else if(b.weaponId === 'pierce') weaponDamage.pierce += damage;
          
          z.hp -= damage;

          if(superCrit){
            spawnFloatingText('ìŠˆí¼ í¬ë¦¬í‹°ì»¬!!', z.x, z.y-12, '#ff0000');
          } else if(crit){
            spawnFloatingText('í¬ë¦¬í‹°ì»¬!', z.x, z.y-12, '#fbbf24');
          }

          // ê°•ë ¥ì´ DOT & ë„‰ë°± & ê²€ íƒ€ê²© í…ìŠ¤íŠ¸
          if(b.weaponId === 'power'){
            if(buffs.powerBurn80) z.powerBurnTime = Math.max(z.powerBurnTime, 10000);
            if(buffs.powerKnockback){
              const ang = Math.atan2(z.y - b.y, z.x - b.x);
              z.x += Math.cos(ang) * 10;
              z.y += Math.sin(ang) * 10;
            }
          } else if(b.weaponId === 'sword'){
            spawnFloatingText('ìŠ¤ë§¤ì‹œ!', z.x, z.y-10, '#e2e8f0');
          }
          
          // ìƒëª…ë ¥ í¡ìˆ˜ (1% í™•ë¥ )
          if(buffs.lifeSteal && Math.random() < 0.01){
            player.health = Math.min(player.maxHealth, player.health + 10);
            spawnFloatingText('+10', player.x, player.y-20, '#10b981');
          }
          
          // ê´€í†µ ìŠ¬ë¡œìš° (3ì´ˆê°„ 10% ê°ì†Œ)
          if(buffs.pierceSlow && b.weaponId === 'pierce'){
            if(!slowedEnemies.find(se => se.enemy === z)){
              const originalSpeed = z.speed;
              z.speed *= 0.9; // 10% ê°ì†Œ
              slowedEnemies.push({ enemy: z, originalSpeed, timer: 3000 });
            }
          }

          // ê´€í†µ ì²˜ë¦¬
          if(!b.pierce){
            // ê´€í†µëŒ€í¬ ê°•í™” íƒ„í™˜: ê´€í†µí•˜ì§€ ì•Šê³  í™”ì—¼ í­ë°œ
            if(b.isEnhanced && b.weaponId === 'pierce'){
              const additionalDamage = Math.ceil(z.hp * 0.15); // ì  ì²´ë ¥ 15% ì¶”ê°€ ë°ë¯¸ì§€
              z.hp -= additionalDamage;
              
              // í™”ì—¼ í­ë°œ ìƒì„±
              flameExplosions.push({ x: b.x, y: b.y, timer: 100 });
              
              // í­ë°œ ì´í™íŠ¸
              flashTime = 150; flashX = b.x; flashY = b.y; flashR = 120;
              cameraShake = Math.max(cameraShake, 8);
            }
            bullets.splice(j,1);
          }else{
            b.hits++;
            const limit = b.maxPierceHits ?? (buffs.pierceCount ? 10 : 5);
            if(b.hits >= limit) {
              // ê´€í†µëŒ€í¬ ê°ì„±: ê´€í†µ ì™„ë£Œ ì‹œ ìˆ˜ë¥˜íƒ„ í­ë°œ
              if(buffs.pierceAwakening && b.weaponId === 'pierce'){
                explodeGrenade({x: b.x, y: b.y, explodeRadius: 80, damage: 200, fromBuff: true}, false);
              }
              bullets.splice(j,1);
            }
          }

          if(z.hp <= 0){
            let add = Math.ceil(10 + z.r + z.speed/4);
            if(buffs.score15On1pct && Math.random() < 0.01) add = Math.ceil(add * 1.5);
            score += add;

            // í­íƒ„ ì¢€ë¹„ í­ë°œ ì²˜ë¦¬
            if(z.isBomb){
              const dist = Math.hypot(z.x - player.x, z.y - player.y);
              if(dist < 60){ // í­ë°œ ë²”ìœ„ 60
                if(!safeguardActive){
                  let damage = 35;
                  
                  // í”Œë ˆì´ì–´ ê°ì„±: ë°›ëŠ” í”¼í•´ 20% ê°ì†Œ
                  if(buffs.playerAwakening){
                    damage *= 0.8;
                  }
                  
                  player.health -= damage;
                  spawnFloatingText('í­ë°œ! -' + Math.ceil(damage), player.x, player.y-20, '#ff4444');
                  cameraShake = 8;
                  if(player.health <= 0){ 
                    player.health = 0; 
                    running = false; 
                    showOverlay('Game Over','í´ë¦­í•˜ê±°ë‚˜ ì¬ì‹œì‘ ë²„íŠ¼ìœ¼ë¡œ ì¬ì‹œì‘'); 
                  }
                }
                // í­ë°œ ì´í™íŠ¸
                flashTime = 100; flashX = z.x; flashY = z.y; flashR = 60;
              }
            }

            // í”¼ ì›…ë©ì´ ìƒì„± (ì¢€ë¹„ í¬ê¸°ì— ë¹„ë¡€)
            spawnBloodPool(z.x, z.y, z.r);

            if(buffs.zombieExplode){
              explodeGrenade({x: z.x, y: z.y, explodeRadius: 60, damage: 60, fromBuff:false}, true);
            }
            if(buffs.healingOrbs && Math.random() < 0.025){ // 2.5%
              spawnHealingOrb(z.x, z.y);
            }
            
            // ê°•ë ¥ì´ìœ¼ë¡œ ì²˜ì¹˜ ì‹œ ìˆ˜ë¥˜íƒ„ 2ê°œ ë“œë¡­
            if(buffs.powerGrenadeDrop && b.weaponId === 'power'){
              for(let g = 0; g < 2; g++){
                const angle = Math.random() * Math.PI * 2;
                const distance = 30;
                const gx = z.x + Math.cos(angle) * distance;
                const gy = z.y + Math.sin(angle) * distance;
                // ê°•ë ¥í­ë°œ ìˆ˜ë¥˜íƒ„ ìƒì„± (ì¿¨íƒ€ì„ ë¬´ì‹œ)
                const baseRange = 110;
                const range = buffs.grenadeRange ? Math.round(baseRange * 1.5) : baseRange;
                const baseDamage = 340 + (buffs.grenadePlus200And10pctHP ? 200 : 0);
                spawnGrenade({ x: gx, y: gy, vx: 0, vy: 0, born: performance.now(), fuse: 200, explodeRadius: range, damage: baseDamage, fromBuff: true, isPowerGrenade: true });
              }
            }
            
            for(let p=0;p<4;p++){
              const a = Math.random()*Math.PI*2;
              spawnBullet(z.x, z.y, Math.cos(a)*rand(90,240), Math.sin(a)*rand(90,240));
            }
            zombies.splice(i,1);
            if(!b.pierce) break;
          }
        }
      }
    }

    // ì´ì•Œ-ë³´ìŠ¤ ì¶©ëŒ
    for(let bi = bosses.length-1; bi>=0; --bi){
      const boss = bosses[bi]; if(!boss) continue;
      for(let j = bullets.length-1; j>=0; --j){
        const b = bullets[j]; if(!b){ bullets.splice(j,1); continue; }
        const d = Math.hypot(boss.x - b.x, boss.y - b.y);
        if(d < boss.r + b.r){
        let damage = b.damage||0;
        let crit = false;
        let superCrit = false;
        
        // ê¸°ë³¸ì´ ì¹˜ëª…íƒ€ (ë³´ìŠ¤ë„ ë™ì¼)
        if(b.weaponId === 'basic' && buffs.basicCritical && Math.random() < 0.025){
          damage *= 1.7;
          crit = true;
        }
        
        // ê¸°ë³¸ì´ ê°•í™” íƒ„í™˜: ë³´ìŠ¤ë„ ì—°ì† íƒ€ê²©ì‹œ ë°ë¯¸ì§€ ì¦ê°€
        if(b.isEnhanced && b.weaponId === 'basic'){
          const bossKey = `${boss.x}_${boss.y}_${boss.r}`; // ë³´ìŠ¤ ê³ ìœ  í‚¤
          const hitCount = enhancedBulletHits.get(bossKey) || 0;
          enhancedBulletHits.set(bossKey, hitCount + 1);
          
          // ë³´ìŠ¤ëŠ” ìµœëŒ€ 50% ì¦ê°€
          const damageMultiplier = Math.min(0.5, hitCount * 0.01); // 1%ì”© ì¦ê°€
          damage *= (1 + damageMultiplier);
        }
        
        if(b.weaponId === 'pierce' && buffs.pierceCrit20 && Math.random() < 0.2){
          damage *= 1.5;
          crit = true;
        }
        if(b.weaponId === 'power' && (buffs.powerSpeedCrit || buffs.powerAwakening) && Math.random() < 0.2){
          damage *= (buffs.powerAwakening ? 1.8 : 1.5);
          crit = true;
        }
        
        // ê°•ë ¥ ì¹˜ëª…íƒ€ ì‹œìŠ¤í…œ (ë³´ìŠ¤ë„ ë™ì¼)
        if(crit && buffs.superCritical && Math.random() < 0.5){
          damage *= 2.5;
          superCrit = true;
        }
          
          // ê°•ë ¥ì´ ê°ì„±: í•„ìˆ˜ ì¹˜ëª…íƒ€ + ì²´ë ¥ 2% ì¶”ê°€ í”¼í•´
          if(b.weaponId === 'power' && buffs.powerAwakening){
            damage *= 1.8;
            damage += boss.hp * 0.02; // ì²´ë ¥ì˜ 2% ì¶”ê°€ í”¼í•´
            crit = true;
          }
          
          // ìŠ¤ì½”ì–´ ë°ë¯¸ì§€ ë¶€ìŠ¤íŠ¸ ì ìš©
          damage *= getScoreDamageMultiplier();
          
          // í”Œë ˆì´ì–´ ê°ì„±: ì…íˆëŠ” í”¼í•´ 20% ì¦ê°€
          if(buffs.playerAwakening){
            damage *= 1.2;
          }
          
          // ê´€í†µëŒ€í¬ ê´€í†µë ¥: ë³´ìŠ¤ ì²´ë ¥ 1% ì¶”ê°€ í”¼í•´
          if(b.weaponId === 'pierce' && buffs.piercePenetration){
            damage += boss.hp * 0.01;
          }
          
          if(buffs.bossDamage) damage *= 1.4;
          
          // ë³´ìŠ¤ ë¬´ê¸°ë³„ ë°ë¯¸ì§€ ì¶”ì 
          if(b.weaponId === 'basic') weaponDamage.basic += damage;
          else if(b.weaponId === 'power') weaponDamage.power += damage;
          else if(b.weaponId === 'pierce') weaponDamage.pierce += damage;
          
          boss.hp -= damage;

        if(superCrit){
          spawnFloatingText('ìŠˆí¼ í¬ë¦¬í‹°ì»¬!!', boss.x, boss.y-boss.r-6, '#ff0000');
        } else if(crit){
          spawnFloatingText('í¬ë¦¬í‹°ì»¬!', boss.x, boss.y-boss.r-6, '#fbbf24');
        }
          if(b.weaponId === 'sword'){
            spawnFloatingText('ìŠ¤ë§¤ì‹œ!', boss.x, boss.y-boss.r-6, '#e2e8f0');
          }

          if(!b.pierce){
            // ê´€í†µëŒ€í¬ ê°•í™” íƒ„í™˜: ë³´ìŠ¤ë„ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
            if(b.isEnhanced && b.weaponId === 'pierce'){
              const additionalDamage = Math.ceil(boss.hp * 0.15); // ë³´ìŠ¤ ì²´ë ¥ 15% ì¶”ê°€ ë°ë¯¸ì§€
              boss.hp -= additionalDamage;
              
              // í™”ì—¼ í­ë°œ ìƒì„±
              flameExplosions.push({ x: b.x, y: b.y, timer: 100 });
              
              // í­ë°œ ì´í™íŠ¸
              flashTime = 150; flashX = b.x; flashY = b.y; flashR = 120;
              cameraShake = Math.max(cameraShake, 8);
            }
            bullets.splice(j,1);
          }else{
            b.hits++;
            const limit = b.maxPierceHits ?? (buffs.pierceCount ? 8 : 3);
            if(b.hits >= limit) {
              // ê´€í†µëŒ€í¬ ê°ì„±: ê´€í†µ ì™„ë£Œ ì‹œ ìˆ˜ë¥˜íƒ„ í­ë°œ
              if(buffs.pierceAwakening && b.weaponId === 'pierce'){
                explodeGrenade({x: b.x, y: b.y, explodeRadius: 80, damage: 200, fromBuff: true}, false);
              }
              bullets.splice(j,1);
            }
          }
          if(boss.hp <= 0){
            score += 500;
            const wasMutant = boss.isMutant;
            spawnCard(boss.x, boss.y, wasMutant ? 2 : 1);
            bosses.splice(bi,1);
            cameraShake = 18;
            if(!b.pierce) break;
          }
        }
      }
    }

    // ë³´ìŠ¤ ì´ë™ ë° ê³µê²© ê²½ê³ 
    for(let bi = bosses.length-1; bi>=0; --bi){
      const b = bosses[bi]; if(!b) continue;
      const ang = Math.atan2(player.y - b.y, player.x - b.x);
      
      // ì¤‘ë ¥ì¥ íš¨ê³¼ ì ìš©
      let currentSpeed = b.speed;
      if(buffs.gravityField && Math.hypot(b.x - player.x, b.y - player.y) < 120 + b.r){
        currentSpeed *= 0.75; // 25% ê°ì†Œ
      }
      
      b.x += Math.cos(ang) * currentSpeed * dt; b.y += Math.sin(ang) * currentSpeed * dt;
      const dist = Math.hypot(player.x - b.x, player.y - b.y);
      if(dist < 140 && b.attackCooldown <= 0 && !b.isWarning){
        b.isWarning = true; b.warningTime = performance.now(); b.attackCooldown = 2400;
      }
      if(b.isWarning){
        if(performance.now() - b.warningTime > 1000){
            if(Math.hypot(player.x - b.x, player.y - b.y) < 72){
              if(!safeguardActive){
                registerDamageEvent();
                let damage = 40;
                
                // í”Œë ˆì´ì–´ ê°ì„±: ë°›ëŠ” í”¼í•´ 20% ê°ì†Œ
                if(buffs.playerAwakening){
                  damage *= 0.8;
                }
                
                player.health -= damage;
                cameraShake = 10;
                if(player.health <= 0){ player.health = 0; running = false; showOverlay('Game Over','í´ë¦­í•˜ê±°ë‚˜ ì¬ì‹œì‘ ë²„íŠ¼ìœ¼ë¡œ ì¬ì‹œì‘'); }
              }
            }
          b.isWarning = false;
        }
      }
      if(b.attackCooldown > 0) b.attackCooldown -= dt*1000;
      if(b.y > H + 200) bosses.splice(bi,1);
    }

    // í”Œë ˆì´ì–´-ì¢€ë¹„ ì¶©ëŒ
    for(let i = zombies.length-1; i>=0; --i){
      const z = zombies[i]; if(!z) continue;
      const d = Math.hypot(z.x - player.x, z.y - player.y);
      if(d < z.r + player.r){
        if(safeguardActive){
          // ë¬´ì 
        }else if(buffs.speedDodge && Math.random() < 0.15){
          // íšŒí”¼ ì„±ê³µ - ìˆ˜ë¥˜íƒ„ 3ê°œ
          for(let k = 0; k < 3; k++){
            const angle = Math.random() * Math.PI * 2;
            const dist = 50;
            const tx = player.x + Math.cos(angle) * dist;
            const ty = player.y + Math.sin(angle) * dist;
            // íšŒí”¼ ìˆ˜ë¥˜íƒ„ ìƒì„± (ì¿¨íƒ€ì„ ë¬´ì‹œ)
            const baseRange = 110;
            const range = buffs.grenadeRange ? Math.round(baseRange * 1.5) : baseRange;
            const baseDamage = 340 + (buffs.grenadePlus200And10pctHP ? 200 : 0);
            spawnGrenade({ x: tx, y: ty, vx: 0, vy: 0, born: performance.now(), fuse: 200, explodeRadius: range, damage: baseDamage, fromBuff: true, isDodgeGrenade: true });
          }
        }else{
          registerDamageEvent();
          let damage = 8 + Math.floor(z.r/3);
          if(isLateGame) damage += 5; // 25ë¶„ í›„ 5 ì¶”ê°€ í”¼í•´
          
          // í”Œë ˆì´ì–´ ê°ì„±: ë°›ëŠ” í”¼í•´ 20% ê°ì†Œ
          if(buffs.playerAwakening){
            damage *= 0.8;
          }
          
          player.health -= damage;
          const ang = Math.atan2(player.y - z.y, player.x - z.x);
          player.x += Math.cos(ang) * 18;
          player.y += Math.sin(ang) * 18;
        }
        zombies.splice(i,1);
        if(player.health <= 0){ player.health = 0; running = false; showOverlay('Game Over','í´ë¦­í•˜ê±°ë‚˜ ì¬ì‹œì‘ ë²„íŠ¼ìœ¼ë¡œ ì¬ì‹œì‘'); }
      }
    }

    // ì¹´ë“œ ìˆ˜ì§‘
    for(let i = cards.length-1; i>=0; --i){
      const c = cards[i]; if(!c) continue;
      if(Math.hypot(player.x-c.x, player.y-c.y) < 20){
        const picks = c.picks || 1;
        cards.splice(i,1);
        showCardSelection({picks});
      }
    }

    // íšŒë³µêµ¬ìŠ¬ ìˆ˜ì§‘
    for(let i = healingOrbs.length-1; i>=0; --i){
      const h = healingOrbs[i]; if(!h) continue;
      if(Math.hypot(player.x-h.x, player.y-h.y) < 20){
        player.health = Math.min(player.maxHealth, player.health + 50); // 50 íšŒë³µ
        healingOrbs.splice(i,1);
      } else if(performance.now() - h.born > h.life){
        healingOrbs.splice(i,1);
      }
    }

    // ë– ìˆëŠ” í…ìŠ¤íŠ¸ ì •ë¦¬
    floatingTexts = floatingTexts.filter(ft => (now - ft.born) < ft.life);

    // í”¼ ì›…ë©ì´ ì •ë¦¬
    bloodPools = bloodPools.filter(bp => (now - bp.born) < bp.life);

    if(flashTime>0) flashTime = Math.max(0, flashTime - dt*1000);
    if(cameraShake>0) cameraShake = Math.max(0, cameraShake - dt*60);

    // UI
    scoreEl.textContent = Math.floor(score);
    mobileScore.textContent = Math.floor(score);
    updateHealthDisplay();
    zcountEl.textContent = zombies.length + bosses.length;

    const timeSince = now - lastGrenade;
    grenadeStatusEl.textContent = timeSince >= grenadeCooldown ? 'ìˆ˜ë¥˜íƒ„: ì¤€ë¹„ ì™„ë£Œ (R)' : 'ìˆ˜ë¥˜íƒ„: ì¬ì‚¬ìš© ëŒ€ê¸° ' + Math.ceil((grenadeCooldown - timeSince)/1000) + 's';
  }

  function registerDamageEvent(){
    if(!buffs.safeguard5s) return;
    const now = performance.now();
    safeguardWindow.push(now);
    while(safeguardWindow.length && now - safeguardWindow[0] > 2000) safeguardWindow.shift();
    if(safeguardWindow.length >= 3 && !safeguardActive){
      safeguardActive = true;
      safeguardUntil = now + 5000;
      safeguardWindow = [];
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    ctx.save(); if(cameraShake>0) ctx.translate((Math.random()-0.5)*cameraShake, (Math.random()-0.5)*cameraShake);

    // ë°°ê²½ ê·¸ë¦¬ë“œ
    ctx.save(); ctx.globalAlpha = 0.05;
    for(let gx=0; gx<W; gx+=40){ ctx.fillRect(gx,0,1,H); }
    for(let gy=0; gy<H; gy+=40){ ctx.fillRect(0,gy,W,1); }
    ctx.restore();

    // ì´ì•Œ
    bullets.forEach(b => {
      if(!b) return;
      ctx.save();
      if(b.alpha !== undefined) ctx.globalAlpha = b.alpha;
      ctx.beginPath();
      ctx.fillStyle = b.color || '#fff';
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      if(b.outline){
        ctx.strokeStyle = b.outline;
        ctx.lineWidth = b.isMega ? 3 : 2;
        ctx.stroke();
      }else if(b.weaponId === 'sword'){
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }else if(b.pierce){
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }else if(b.isEnhanced && b.weaponId === 'basic'){
        // ê¸°ë³¸ì´ ê°•í™” íƒ„í™˜: ë¹¨ê°„ìƒ‰ì— ê²€ì€ í…Œë‘ë¦¬
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      ctx.restore();
    });

    // ìˆ˜ë¥˜íƒ„
    grenades.forEach(g => {
      ctx.beginPath();
      // ê³ ì–‘ì´ í« ìˆ˜ë¥˜íƒ„ì€ ë‹¤ë¥¸ ìƒ‰ìƒ
      if(g.isCatPet){
        ctx.fillStyle = '#f59e0b'; // ì£¼í™©ìƒ‰
        ctx.arc(g.x, g.y, 8, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(245,158,11,0.8)';
        ctx.lineWidth = 2;
        ctx.arc(g.x, g.y, 14, 0, Math.PI*2);
        ctx.stroke();
        // ê³ ì–‘ì´ ìˆ˜ë¥˜íƒ„ í‘œì‹œ
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ±', g.x, g.y + 3);
      } else if(g.isChainExplosion){
        // ì—°ì‡„í­ë°œ ìˆ˜ë¥˜íƒ„
        ctx.fillStyle = '#ef4444'; // ë¹¨ê°„ìƒ‰
        ctx.arc(g.x, g.y, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(239,68,68,0.8)';
        ctx.lineWidth = 2;
        ctx.arc(g.x, g.y, 12, 0, Math.PI*2);
        ctx.stroke();
        // ì—°ì‡„í­ë°œ í‘œì‹œ
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ’¥', g.x, g.y + 2);
      } else if(g.isPowerGrenade){
        // ê°•ë ¥í­ë°œ ìˆ˜ë¥˜íƒ„
        ctx.fillStyle = '#8b5cf6'; // ë³´ë¼ìƒ‰
        ctx.arc(g.x, g.y, 7, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(139,92,246,0.8)';
        ctx.lineWidth = 2;
        ctx.arc(g.x, g.y, 13, 0, Math.PI*2);
        ctx.stroke();
        // ê°•ë ¥í­ë°œ í‘œì‹œ
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('âš¡', g.x, g.y + 2);
      } else if(g.isDodgeGrenade){
        // íšŒí”¼ ìˆ˜ë¥˜íƒ„
        ctx.fillStyle = '#10b981'; // ì´ˆë¡ìƒ‰
        ctx.arc(g.x, g.y, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(16,185,129,0.8)';
        ctx.lineWidth = 2;
        ctx.arc(g.x, g.y, 12, 0, Math.PI*2);
        ctx.stroke();
        // íšŒí”¼ í‘œì‹œ
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ’¨', g.x, g.y + 2);
      } else if(g.isQueuedGrenade){
        // ëŒ€ê¸°ì—´ ìˆ˜ë¥˜íƒ„ (ì´ì¤‘ ê¸°í­)
        ctx.fillStyle = '#f97316'; // ì£¼í™©ìƒ‰
        ctx.arc(g.x, g.y, 6, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(249,115,22,0.8)';
        ctx.lineWidth = 2;
        ctx.arc(g.x, g.y, 12, 0, Math.PI*2);
        ctx.stroke();
        // ëŒ€ê¸°ì—´ í‘œì‹œ
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('âœ¨', g.x, g.y + 2);
      } else {
        // í”Œë ˆì´ì–´ ìˆ˜ë¥˜íƒ„
        ctx.fillStyle = '#f1c40f';
        ctx.arc(g.x, g.y, 8, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(241,196,15,0.6)';
        ctx.arc(g.x, g.y, 14, 0, Math.PI*2);
        ctx.stroke();
      }
    });

    if(flashTime>0){
      ctx.save();
      ctx.globalAlpha = Math.min(0.9, flashTime/220);
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,150,80,0.18)';
      ctx.arc(flashX, flashY, flashR*1.8,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // ë… ì›…ë©ì´
    poisonPools.forEach(pool => {
      ctx.beginPath();
      ctx.fillStyle = 'rgba(34,197,94,0.25)';
      ctx.arc(pool.x, pool.y, pool.r, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2;
      ctx.stroke();
    });
    
    // í™”ì—¼ ì¥íŒ
    flamePools.forEach(pool => {
      const age = performance.now() - pool.born;
      const alpha = Math.max(0, 1 - age/pool.life);
      ctx.save();
      ctx.globalAlpha = alpha * 0.3;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,69,0,0.4)';
      ctx.arc(pool.x, pool.y, pool.r, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#ff4500';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
    });

    // í™”ì—¼êµ¬ìŠ¬
    flameOrbs.forEach(orb => {
      const x = player.x + Math.cos(orb.angle) * orb.distance;
      const y = player.y + Math.sin(orb.angle) * orb.distance;
      ctx.beginPath();
      ctx.fillStyle = '#ff6b35';
      ctx.arc(x, y, orb.r, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#ff4500';
      ctx.lineWidth = 2;
      ctx.stroke();
    });

    // ì¢€ë¹„
    zombies.forEach(z => {
      if(!z) return;
      const t = performance.now()*0.002 + z.colorPhase*10;
      const hue = 120 - Math.sin(t)*40;
      
      // ìŠ¬ë¡œìš°ëœ ì ì€ íŒŒë€ìƒ‰ìœ¼ë¡œ, í­íƒ„ ì¢€ë¹„ëŠ” ë¹¨ê°„ìƒ‰ìœ¼ë¡œ
      const isSlowed = slowedEnemies.find(se => se.enemy === z);
      let color = `hsl(${hue} 60% 45%)`;
      if(z.isBomb) color = '#ff4444';
      else if(isSlowed) color = '#3b82f6';
      
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.arc(z.x, z.y, z.r, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.arc(z.x - z.r/3, z.y - z.r/5, Math.max(1.6, z.r*0.18), 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(z.x + z.r/4, z.y - z.r/5, Math.max(1.6, z.r*0.18), 0, Math.PI*2); ctx.fill();

      // í­íƒ„ ì¢€ë¹„ í‘œì‹œ
      if(z.isBomb){
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ’£', z.x, z.y + 2);
      }

      // í™”ìƒ ë°”
      if(z.burnTime > 0 || z.powerBurnTime > 0){
        ctx.fillStyle = '#ff4500';
        const ratio = Math.min(1, ((z.burnTime>0?z.burnTime:0) + (z.powerBurnTime>0?z.powerBurnTime:0)) / 10000);
        ctx.fillRect(z.x - z.r, z.y - z.r - 8, (z.r * 2) * ratio, 3);
      }
    });

    // ë³´ìŠ¤
    bosses.forEach(b => {
      if(!b) return;
      ctx.beginPath(); ctx.fillStyle = b.isMutant ? '#7c2d12' : '#b22222'; ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(b.x - b.r/3, b.y - b.r/4, b.r*0.18, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(b.x + b.r/4, b.y - b.r/4, b.r*0.18, 0, Math.PI*2); ctx.fill();
      if(b.isWarning){
        ctx.beginPath(); ctx.strokeStyle = 'rgba(255,40,40,0.7)'; ctx.lineWidth = 4; ctx.arc(b.x, b.y, 140, 0, Math.PI*2); ctx.stroke();
      }
    });

    // ì¹´ë“œ
    cards.forEach(c => {
      if(!c) return;
      ctx.beginPath(); ctx.fillStyle = c.color; ctx.arc(c.x, c.y, c.r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
      ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.fillText(c.picks===2?'â…¡':'?', c.x, c.y + 4);
    });

    // íšŒë³µêµ¬ìŠ¬
    healingOrbs.forEach(h => {
      if(!h) return;
      ctx.beginPath(); ctx.fillStyle = h.color; ctx.arc(h.x, h.y, h.r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
    });

    // í”Œë ˆì´ì–´(ë¬´ì  ì”ìƒ)
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    if(safeguardActive){
      ctx.save();
      for(let s=0;s<4;s++){
        ctx.globalAlpha = 0.12 * (4-s);
        ctx.translate(player.x - s*4, player.y - s*2);
        ctx.rotate(ang);
        ctx.fillStyle = '#94a3b8';
        ctx.beginPath(); ctx.rect(-12,-14,24,28); ctx.fill();
        ctx.beginPath(); ctx.arc(16,0,10,0,Math.PI*2); ctx.fill();
        ctx.restore();
        ctx.save();
      }
      ctx.restore();
    }
    ctx.save();
    ctx.translate(player.x, player.y); ctx.rotate(ang); ctx.fillStyle = '#e6eef8';
    ctx.beginPath(); ctx.rect(-12,-14,24,28); ctx.fill();
    ctx.beginPath(); ctx.arc(16,0,10,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111827'; ctx.fillRect(-6,-4,30,8);
    ctx.restore();

    // ì¤‘ë ¥ì¥
    if(buffs.gravityField){
      ctx.save();
      ctx.globalAlpha = 0.1;
      ctx.beginPath();
      ctx.strokeStyle = '#60a5fa';
      ctx.lineWidth = 3;
      ctx.arc(player.x, player.y, 120, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // ê³ ì–‘ì´ í«
    if(buffs.catPet){
      const petX = player.x + 30;
      const petY = player.y - 20;
      ctx.beginPath();
      ctx.fillStyle = '#f59e0b';
      ctx.arc(petX, petY, 6, 0, Math.PI*2);
      ctx.fill();
      // ê³ ì–‘ì´ ê·€
      ctx.beginPath();
      ctx.fillStyle = '#f59e0b';
      ctx.moveTo(petX-4, petY-6);
      ctx.lineTo(petX-2, petY-10);
      ctx.lineTo(petX, petY-6);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(petX, petY-6);
      ctx.lineTo(petX+2, petY-10);
      ctx.lineTo(petX+4, petY-6);
      ctx.fill();
    }
    
    // ê°•ì•„ì§€ í«
    if(buffs.dogPet){
      const dogX = player.x - 30;
      const dogY = player.y - 20;
      ctx.beginPath();
      ctx.fillStyle = '#8b5cf6';
      ctx.arc(dogX, dogY, 6, 0, Math.PI*2);
      ctx.fill();
      // ê°•ì•„ì§€ ê·€
      ctx.beginPath();
      ctx.fillStyle = '#8b5cf6';
      ctx.moveTo(dogX-4, dogY-6);
      ctx.lineTo(dogX-2, dogY-10);
      ctx.lineTo(dogX, dogY-6);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(dogX, dogY-6);
      ctx.lineTo(dogX+2, dogY-10);
      ctx.lineTo(dogX+4, dogY-6);
      ctx.fill();
      // ê°•ì•„ì§€ ì½”
      ctx.beginPath();
      ctx.fillStyle = '#000';
      ctx.arc(dogX, dogY+1, 1, 0, Math.PI*2);
      ctx.fill();
    }

    // ì¡°ì¤€ì„ 
    ctx.beginPath(); ctx.strokeStyle = 'rgba(230,238,248,.9)'; ctx.lineWidth = 1.2; ctx.arc(mouse.x, mouse.y, 10, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(mouse.x-16, mouse.y); ctx.lineTo(mouse.x+16, mouse.y); ctx.moveTo(mouse.x, mouse.y-16); ctx.lineTo(mouse.x, mouse.y+16); ctx.stroke();

    // í”¼ ì›…ë©ì´
    bloodPools.forEach(bp => {
      const age = performance.now() - bp.born;
      const alpha = Math.max(0, 1 - age/bp.life);
      ctx.save();
      ctx.globalAlpha = alpha * 0.6; // ë°˜íˆ¬ëª…í•˜ê²Œ
      ctx.fillStyle = '#22c55e'; // ì´ˆë¡ìƒ‰
      ctx.beginPath();
      ctx.arc(bp.x, bp.y, bp.size * 0.8, 0, Math.PI*2); // ì¢€ë¹„ í¬ê¸°ì˜ 80%
      ctx.fill();
      ctx.restore();
    });

    // ë– ìˆëŠ” í…ìŠ¤íŠ¸
    floatingTexts.forEach(ft => {
      const age = performance.now() - ft.born;
      const alpha = Math.max(0, 1 - age/ft.life);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = ft.color;
      ctx.font = 'bold 12px system-ui';
      ctx.fillText(ft.text, ft.x, ft.y - age*0.04);
      ctx.restore();
    });

    ctx.restore();

    // í•˜ë‹¨ ì ìˆ˜ / ìƒë‹¨ ë³´ìŠ¤ë°”
    ctx.font = '14px system-ui'; ctx.fillStyle = 'rgba(230,238,248,.9)'; ctx.fillText('Score: '+Math.floor(score), 12, H-12);
    if(bosses.length>0){
      const b = bosses[0];
      const barW = 360; const pct = Math.max(0, b.hp / b.maxHp);
      ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(W/2 - barW/2 - 2, 18-2, barW+4, 24+4);
      ctx.fillStyle = b.isMutant ? '#7c2d12' : '#b22222'; ctx.fillRect(W/2 - barW/2, 18, barW * pct, 24);
      ctx.strokeStyle = '#e6eef8'; ctx.strokeRect(W/2 - barW/2, 18, barW, 24);
      ctx.fillStyle = '#e6eef8'; ctx.fillText(b.isMutant ? 'MUTANT BOSS' : 'BOSS', W/2 - 48, 36);
    }
  }

  function loop(ts){
    try{
      const dt = Math.min(0.033, (ts - lastTime)/1000 || 0);
      lastTime = ts;
      update(dt);
      draw();
    }catch(e){ console.error('Game loop error', e); }
    requestAnimationFrame(loop);
  }

  function showOverlay(title, sub){
    overlay.style.display='block';
    document.getElementById('overlay-title').textContent=title;
    document.getElementById('overlay-sub').textContent=sub;
    
    // ìµœê³ ì ìˆ˜ ì—…ë°ì´íŠ¸
    updateHighScores(score);
    
    // ë¬´ê¸°ë³„ ë°ë¯¸ì§€ í†µê³„ í‘œì‹œ
    const totalDamage = weaponDamage.basic + weaponDamage.power + weaponDamage.pierce;
    if(totalDamage > 0){
      const damageText = `
        <div style="margin-top:12px;font-size:12px;color:#cbd5e1;">
          <div>ë¬´ê¸°ë³„ ë°ë¯¸ì§€:</div>
          <div>ê¸°ë³¸ì´: ${weaponDamage.basic.toLocaleString()} (${Math.round(weaponDamage.basic/totalDamage*100)}%)</div>
          <div>ê°•ë ¥ì´: ${weaponDamage.power.toLocaleString()} (${Math.round(weaponDamage.power/totalDamage*100)}%)</div>
          <div>ê´€í†µëŒ€í¬: ${weaponDamage.pierce.toLocaleString()} (${Math.round(weaponDamage.pierce/totalDamage*100)}%)</div>
        </div>
      `;
      document.getElementById('overlay-sub').innerHTML = sub + damageText;
    }
  }

  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    const key = e.key.toLowerCase();
    if(key === 'q'){ currentWeapon = (currentWeapon - 1 + weapons.length) % weapons.length; updateWeaponStats(); }
    else if(key === 'e'){ currentWeapon = (currentWeapon + 1) % weapons.length; updateWeaponStats(); }
    else if(key === 'x'){ currentWeapon = 2; updateWeaponStats(); }
    
    // ë°œí‚¤ë¦¬ì˜ ì¶•ë³µ: ê°•ë ¥ì´ ì™¸ ë‹¤ë¥¸ ë¬´ê¸° ì‚¬ìš©ì‹œ íš¨ê³¼ í•´ì œ
    if(valkyrieBlessingActive && currentWeapon !== 1){
      valkyrieBlessingActive = false;
      powerShotCount = 0;
      applyWeaponBuffs();
      updateWeaponStats();
    }
    
    // ê°•ë ¥ì´ ì—°ì‚¬: ë‹¤ë¥¸ ë¬´ê¸°ì—ì„œ ê°•ë ¥ì´ìœ¼ë¡œ ì „í™˜ì‹œ ì´ì† ë²„í”„ ë°œë™
    if(buffs.powerRapidFire && powerWeaponSwitchCooldown <= 0){
      const previousWeapon = currentWeapon;
      if(key === 'q'){ 
        const newWeapon = (currentWeapon - 1 + weapons.length) % weapons.length;
        if(newWeapon === 1 && previousWeapon !== 1){
          powerWeaponSwitchTimer = 1; // íƒ€ì´ë¨¸ ì‹œì‘
          powerWeaponSwitchCooldown = 10000; // 10ì´ˆ ì¿¨íƒ€ì„
        }
      }
      else if(key === 'e'){ 
        const newWeapon = (currentWeapon + 1) % weapons.length;
        if(newWeapon === 1 && previousWeapon !== 1){
          powerWeaponSwitchTimer = 1;
          powerWeaponSwitchCooldown = 10000;
        }
      }
      else if(key === 'x'){ 
        if(currentWeapon !== 2 && 2 === 1){ // ê´€í†µëŒ€í¬ì—ì„œ ê°•ë ¥ì´ìœ¼ë¡œ
          powerWeaponSwitchTimer = 1;
          powerWeaponSwitchCooldown = 10000;
        }
      }
    }
    else if(key === 'r'){
      const ok = throwGrenade(mouse.x, mouse.y);
      if(ok) maybeQueueExtraGrenade(mouse.x, mouse.y);
    }
    if(e.key === 'p'){ running = !running; pauseBtn.textContent = running? 'ì¼ì‹œì •ì§€':'ì¬ê°œ'; }
  });
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
  canvas.addEventListener('mousemove', e => { const rect = canvas.getBoundingClientRect(); mouse.x = (e.clientX-rect.left)*(canvas.width/rect.width); mouse.y = (e.clientY-rect.top)*(canvas.height/rect.height); });
  canvas.addEventListener('mousedown', e => { mouse.down = true; });
  window.addEventListener('mouseup', e => { mouse.down = false; });
  canvas.addEventListener('touchstart', e => { e.preventDefault(); mouse.down = true; const t = e.touches[0]; const rect = canvas.getBoundingClientRect(); mouse.x = (t.clientX-rect.left)*(canvas.width/rect.width); mouse.y = (t.clientY-rect.top)*(canvas.height/rect.height); });
  canvas.addEventListener('touchend', e => { e.preventDefault(); mouse.down = false; });
  canvas.addEventListener('touchmove', e => { const rect = canvas.getBoundingClientRect(); const t = e.touches[0]; mouse.x = (t.clientX-rect.left)*(canvas.width/rect.width); mouse.y = (t.clientY-rect.top)*(canvas.height/rect.height); });

  pauseBtn.addEventListener('click', ()=>{ running = !running; pauseBtn.textContent = running? 'ì¼ì‹œì •ì§€':'ì¬ê°œ'; });
  restartBtn.addEventListener('click', ()=>{ reset(); });
  overlayBtn.addEventListener('click', ()=>{ reset(); });
  overlay.addEventListener('click', ()=>{ reset(); });
  startBtn.addEventListener('click', ()=>{ 
    startOverlay.style.display = 'none'; 
    running = true;
    
    // ê²Œì„ ì‹œì‘ì‹œ ë°”ë¡œ ë²„í”„ ì„ íƒ ì¹´ë“œ ì œê³µ
    setTimeout(() => {
      if(running) { // ê²Œì„ì´ ì—¬ì „íˆ ì§„í–‰ ì¤‘ì¸ì§€ í™•ì¸
        showCardSelection({picks: 1});
      }
    }, 100); // 0.1ì´ˆ í›„ ì¹´ë“œ ì œê³µ
  });

  // ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± ì´ë²¤íŠ¸
  function getJoystickPos(e) {
    const rect = joystick.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const touch = e.touches ? e.touches[0] : e;
    return {
      x: touch.clientX - centerX,
      y: touch.clientY - centerY
    };
  }

  joystick.addEventListener('touchstart', (e) => {
    e.preventDefault();
    joystickActive = true;
    const pos = getJoystickPos(e);
    joystickCenter = {x: pos.x, y: pos.y};
  });

  joystick.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if(!joystickActive) return;
    const pos = getJoystickPos(e);
    const dx = pos.x - joystickCenter.x;
    const dy = pos.y - joystickCenter.y;
    const distance = Math.hypot(dx, dy);
    const maxDistance = 25;
    
    if(distance <= maxDistance) {
      joystickOffset.x = dx / maxDistance;
      joystickOffset.y = dy / maxDistance;
      joystickKnob.style.transform = `translate(${dx - 15}px, ${dy - 15}px)`;
    } else {
      const angle = Math.atan2(dy, dx);
      joystickOffset.x = Math.cos(angle);
      joystickOffset.y = Math.sin(angle);
      joystickKnob.style.transform = `translate(${Math.cos(angle) * maxDistance - 15}px, ${Math.sin(angle) * maxDistance - 15}px)`;
    }
  });

  joystick.addEventListener('touchend', (e) => {
    e.preventDefault();
    joystickActive = false;
    joystickOffset.x = 0;
    joystickOffset.y = 0;
    joystickKnob.style.transform = 'translate(-50%, -50%)';
  });

  // ì´ë™ì‹ ê³µê²© ì¡°ì´ìŠ¤í‹± ì´ë²¤íŠ¸
  function getAttackJoystickPos(e) {
    const rect = attackJoystick.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const touch = e.touches ? e.touches[0] : e;
    return {
      x: touch.clientX - centerX,
      y: touch.clientY - centerY
    };
  }

  attackJoystick.addEventListener('touchstart', (e) => {
    e.preventDefault();
    attackJoystickActive = true;
    const pos = getAttackJoystickPos(e);
    attackJoystickCenter = {x: pos.x, y: pos.y};
  });

  attackJoystick.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if(!attackJoystickActive) return;
    const pos = getAttackJoystickPos(e);
    const dx = pos.x - attackJoystickCenter.x;
    const dy = pos.y - attackJoystickCenter.y;
    const distance = Math.hypot(dx, dy);
    const maxDistance = 30;
    
    if(distance <= maxDistance) {
      attackJoystickOffset.x = dx / maxDistance;
      attackJoystickOffset.y = dy / maxDistance;
      attackJoystickKnob.style.transform = `translate(${dx - 17.5}px, ${dy - 17.5}px)`;
    } else {
      const angle = Math.atan2(dy, dx);
      attackJoystickOffset.x = Math.cos(angle);
      attackJoystickOffset.y = Math.sin(angle);
      attackJoystickKnob.style.transform = `translate(${Math.cos(angle) * maxDistance - 17.5}px, ${Math.sin(angle) * maxDistance - 17.5}px)`;
    }
  });

  attackJoystick.addEventListener('touchend', (e) => {
    e.preventDefault();
    attackJoystickActive = false;
    attackJoystickOffset.x = 0;
    attackJoystickOffset.y = 0;
    attackJoystickKnob.style.transform = 'translate(-50%, -50%)';
  });

  // ëª¨ë°”ì¼ ë²„íŠ¼ ì´ë²¤íŠ¸
  mobileGrenadeBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const ok = throwGrenade(player.x + 100, player.y - 100);
    if(ok) maybeQueueExtraGrenade(player.x + 100, player.y - 100);
  });

  mobileWeaponBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    currentWeapon = (currentWeapon + 1) % weapons.length;
    updateWeaponStats();
  });

  // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì´ˆê¸°í™”
  function initMobileControls(){
    // ê³µê²© ì¡°ì´ìŠ¤í‹± ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (í™”ë©´ ìš°í•˜ë‹¨)
    const rect = canvas.getBoundingClientRect();
    const right = window.innerWidth - 120;
    const bottom = window.innerHeight - 120;
    
    attackJoystickPosition.x = right;
    attackJoystickPosition.y = bottom;
    attackJoystick.style.left = right + 'px';
    attackJoystick.style.top = bottom + 'px';
    
    // ë²„íŠ¼ ìœ„ì¹˜ ì„¤ì •
    mobileGrenadeBtn.style.left = (right - 80) + 'px';
    mobileGrenadeBtn.style.top = bottom + 'px';
    
    mobileWeaponBtn.style.left = (right - 80) + 'px';
    mobileWeaponBtn.style.top = (bottom - 80) + 'px';
  }
  
  // ê²Œì„ ì‹œì‘ ì‹œê°„ ì´ˆê¸°í™”
  gameStartTime = performance.now();
  
  // ìµœê³ ì ìˆ˜ í‘œì‹œ ì´ˆê¸°í™”
  updateHighScoresDisplay();
  
  // ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ì´ˆê¸°í™”
  initMobileControls();
  
  // í™”ë©´ í¬ê¸° ë³€ê²½ ì‹œ ì»¨íŠ¸ë¡¤ ìœ„ì¹˜ ì¬ì¡°ì •
  window.addEventListener('resize', initMobileControls);
  window.addEventListener('orientationchange', () => {
    setTimeout(initMobileControls, 100);
  });
  
  for(let i=0;i<4;i++) spawnZombie();
  applyWeaponBuffs();
  updateWeaponStats();
  updateHealthDisplay();
  requestAnimationFrame(loop);
  console.log('Zombie Shooter ready â€” WASD to move, mouse to aim, click or Space to shoot. Q/E/X to switch weapons, R to throw grenade.');
})();
</script>
</body>
</html>